%replace true                           by   '1'b;
%replace false                          by   '0'b;

%replace e$object_not_found             by   1032;
%replace e$no_msg_server_for_queue      by   2817;
%replace e$timeout                      by   1081;
%replace e$end_of_file                  by   1025;
%replace e$invalid_eventid              by   1183;

%replace seq_file                       by      3;
%replace ignored_rec_size               by    128;
%replace Separation_Char                by    144;

%replace public$room                    by      1;

declare compress_name          entry (char(*)var,char(*)var);
declare send_msg_to_queue      entry (char(*)var,char(*)var,bin(15),char(*)var,
                                      bin(15));
        
declare s$attach_event         entry (char(256)var, bin(31), bin(31), bin(15));
declare s$attach_port          entry (char(*) var, char(*) var, bin(15), bin(15),
                                      bin(15));
declare s$close                entry (bin(15), bin(15));
declare s$create_file          entry (char(256)var, bin(15), bin(15), bin(15));
declare s$cv_to_int_date_time  entry (char(*)var, bin(31), bin(15));
declare s$cv_to_string_date_time
                               entry (bin(31), char(*) var);
declare s$expand_module_name   entry (char(66)var, char(66)var, bin(15));
declare s$expand_path          entry (char(256)var, char(32)var,
                                      char(256)var, bin(15));
declare s$detach_port          entry (bin(15), bin(15));
declare s$get_current_dir      entry (char(*)var);
declare s$get_processes        entry (char(65) var, char(32) var, char(66) var,
                                      bin(15), bin(15), bin(31), bin(15));
declare s$get_process_info     entry (bin(31), bin(15), bin(15));
declare s$int_date_time        entry (bin(31));
declare s$open                 entry (bin(15), bin(15), bin(15), bin(15), 
                                      bin(15), bin(15), char(*) var, bin(15));
declare s$notify_event         entry (bin(31), bin(31), bin(15));
declare s$parse_command        entry (char(*)var,bin(15),
                                      char(*)var,bin(15),
                                      char(*)var,char(*)var,
                                      char(*)var,bit(1) aligned,
                                      char(*)var,bit(1) aligned,
                                      char(*)var,bit(1) aligned,
                                      char(*)var);
declare s$read_event           entry (bin(31), bin(31), bin(31), bin(15));
declare s$rename               entry (char(256) var, char(256) var, bin(15));
declare s$seq_read             entry (bin(15), bin(15), bin(15), char(*),
                                      bin(15));
declare s$set_implicit_locking entry (char(256)var, bin(15), bin(15));
declare s$sleep                entry (bin(31), bin(15));
declare s$start_process        entry (char(256)var, char(256)var, char(256)var,
                                      bin(15),      char(256)var, char(66) var,
                                      bin(15),      char(32)var, bin(31), bin(15));
declare s$stop_process         entry (bin(31), bin(15));
declare s$string_date_time     entry (char(32) var);
declare s$task_setup_wait      entry (bin(31), bin(15), bin(15), bin(31),
                                      bin(31), bin(31), bin(15), bin(15));
declare s$task_wait_event      entry (bin(31), bin(31), bin(15), bin(31),
                                      bin(15), bin(31), bin(31), bin(15));
declare s$wait_event           entry (bin(15), (*)bin(31), (*)bin(31),
                                      bin(31), bin(15), bin(15));
declare die                    entry (bin(15), char(*) var, char(*) var);

declare  encode_byte           entry (bin(15)) returns (char(2) var);
declare  encode_string         entry (char(*) var, char(*) var);

%nolist;  %include 'Messages.incl.pl1';       %list;
%nolist;  %include 'Queues.incl.pl1';         %list;
%nolist;  %include 'Debug.incl.pl1';          %list;
%nolist;  %include 'Stat.strux.incl.pl1';     %list;
%nolist;  %include 'Lists.strux.incl.pl1';    %list;
%nolist;  %include 'Lists.incl.pl1';          %list;
%nolist;  %include 'TimeAfterTime.incl.pl1';  %list;
%nolist;  %include 'Context_defs.incl.pl1';   %list;

%nolist;  %include 'process_control.incl.pl1';  %list;
%nolist;  %include 'cc_habitat_strux.incl.pl1'; %list;
%nolist;  %include 'cc_sys_defs.incl.pl1';      %list;

declare  habitat_queue        pointer external initial (null());
declare  habitatQ_queue       pointer external initial (null());
declare  habitat_db_queue     pointer external initial (null());
declare  newuser_queue        pointer external initial (null());

declare  habitat_qid          bin(31) external initial (0);

%replace server_event                   by    1;   /* External (small) Q    */
%replace serverQ_event                  by    2;   /* Internal (big) Q      */
%replace db_event                       by    3;
%replace newuser_event                  by    4;
%replace tact_event                     by    5;
%replace obn_event                      by    6;
%replace stat_event                     by    7;
%replace max_events                     by    7;

declare   event_index    bin(15) external;

declare  BUGON           bit(1) static external initial(false);
declare  BUGON_high      bit(1) static external initial(false);

declare habitat_log      bit(1) aligned static external;
declare balanced_loading bit(1) aligned static external;
declare restarting       bit(1) aligned static external;

declare max_regionprocs  binary(15) external;
%replace MAX_PROCS       by 3;
declare region_proc_list (MAX_PROCS) pointer external;

declare block_users      bit(1) aligned static external initial(true);

declare Transit_list     pointer static external initial(null());
declare 1 transit        based,
          2 avatar           bin(31),
          2 user_q           bin(31),
          2 region_id        bin(31),
          2 region_owner     bin(31),
          2 login_request    char(10) var,
          2 login_data       char(12),
          2 got_db_response  bit(1),
          2 got_init_request bit(1),
          2 cc_guide         bit(1),
          2 filler           bit(13);
                             
declare RegionQ (10) pointer static external;
declare keep_cnt bin(15) static external initial(0);
declare 1 hi_water external,
          2 users  binary(15) initial(0),
          2 procs  binary(15) initial(0);
declare curr_users external binary(15) initial(0);
                             
%page;                       
habitat:  procedure options (main);
   declare  event                       bin (31);
   declare  task                        bin (15);
   declare  count                       bin (31);
   declare  code                        bin (15);
   declare  index                       bin (15);
   declare  status                      bin (31);
   declare  done                        bit (1);


   call initialize_process;

   do  while (true);
       call s$task_wait_event (Master_ei, -1, task, event, event_index,
                               count, status, code);
       if (code = 0)  then do;

           if (task = server_event  |  
               task = serverQ_event)  then call handle_msg (task);

             else if (task = tact_event) then do;
                   call ProcessTact;
                   call GetTactInfo (tact_ei, tact_ec);
                   call s$task_setup_wait (Master_ei, tact_event, 1,
                                           tact_ei, tact_ec, -1, index, code);
                   end;

             else if (task = db_event)      then  call resend_msg (habitat_db_queue);
             else if (task = newuser_event) then  call resend_msg (newuser_queue);
             else if (task = obn_event)     then  call resend_msg (Q_ptrs (event_index));
             else if (task = stat_event)    then  call resend_msg (stat_queue_ptr);
             else if (task > max_events)    then  call resend_msg (RegionQ (task-max_events));
           end;
         else do;
           call debug_msg (code, ' Habitat problem in wait event');
           if (code = e$invalid_eventid) then stop;
           end;
       end;

end habitat;

%page;
handle_msg: procedure (task);
declare task        bin(15);
/* locals */
declare mtype       bin(31);
declare buffer      character(1024);
declare obuf        character(1024) varying;
declare len         bin(31);
declare uid         bin(31);
declare qid         bin(31);

 do while (true);
    if (task = server_event)
        then call get_message (habitat_queue,  event_index, mtype, buffer, 
                               length(buffer), len, uid, qid);
        else call get_message (habitatQ_queue, event_index, mtype, buffer, 
                               length(buffer), len, uid, qid);
    if (mtype = -1) then return;

    obuf = substr(buffer,1,len); 

    if (mtype = MSG$NEW_LOGIN) then 
         call new_login (obuf,uid,qid);

    else if (mtype = MSG$CURRENT_REGION) then 
         call process_current_location (uid,qid,addr(buffer),len);

    else if (mtype = MSG$LOOKUP_RESULTS) then 
         call initialize_region (addr(buffer));

    else if (mtype = MSG$CHANGE_ROOM) then 
         call change_room (uid,qid,obuf);

    else if (mtype = MSG$CHANGE_ROOM_RESULT) then 
         call check_change_result (uid,qid,addr(buffer),len);

    else if (mtype = MSG$ADD_OBJECTS | mtype = MSG$ADD_USER) then 
       call pass_to_new_region (addr(buffer),mtype,len,uid,qid);

    else if (mtype = MSG$FIND_CURRENT_REGION) then 
         call preliminary_new_login (uid,qid) ;

    else if (mtype = MSG$FIND_NAME) then 
         call find_by_name (obuf,uid,qid) ;

    else if (mtype = MSG$HABITAT_OLM) then 
         call send_olm_msg (addr(buffer),uid,qid) ;

    else if (mtype = MSG$USER_UNPLUGGED) then 
       call reset_user (qid,uid);

    else if (mtype = MSG$MAIL_ARRIVED) then 
       call signal_mail_arrival (addr(buffer),uid);

    else if (mtype = MSG$USER_STATS) then 
       call list_latest_users (obuf,uid);

    else if (mtype = MSG$REROUTE) then 
       call reroute_message (obuf,uid,qid);

    else if (mtype = MSG$PROCESS_GOING) then 
         call region_process_woke_up (buffer);

    else if (mtype = MSG$STATFLUSH) then 
         call Stat_Flush;          

    else if (mtype = MSG$DEBUG_MSG) then 
         call process_console_msg (obuf);          

    else if (mtype = MSG$INTERNAL) then 
         call process_internal (obuf);

    else call trace_msg (' Unknown type('  ||  ltrim(mtype)  ||
                         ') uid('          ||  ltrim(uid)    ||
                         ') qid('          ||  ltrim(qid)    || '):' || obuf);
    end;
end handle_msg;
%page;
preliminary_new_login: procedure (uid,qid);
declare uid         bin(31);
declare qid         bin(31);

declare tp          pointer;
declare msg_data    char(4) based (tp);

     /* LOGIN: At this point the user has just begun to load Habitat. */
     /* As a result, we request habitat_db to lookup the user's cur-  */
     /* rent region.  Therefore, we have to wait for BOTH the reply   */
     /* from habitat_db and the user's initial request before we can  */
     /* actually continue processing.  Note that if we don't get a    */
     /* user request, the load failed and he is still "connected" to  */
     /* a Roomer (ie not hung).                                       */

    /* Ask habitat_db to read db to find out where the guy was last time... */

    allocate transit set (tp);
    tp->transit.avatar           = uid;
    tp->transit.user_q           = qid;
    tp->transit.region_id        = 0;
    tp->transit.region_owner     = 0;
    tp->transit.login_request    = '';
    tp->transit.login_data       = '';
    tp->transit.got_db_response  = false;
    tp->transit.got_init_request = false;

    if (substr(q_context.screen_name,1,4) = 'CCG ')
        then tp->transit.cc_guide = true;
        else tp->transit.cc_guide = false;

    if (^block_users) then
        call send_message (habitat_db_queue, MSG$FIND_CURRENT_REGION,
                       msg_data, 8, 0, habitat_qid);
    else do;
        tp->transit.region_id = -1;
        tp->transit.got_db_response = true;
        end;
         
    call add_to_list (Transit_list,tp);

end preliminary_new_login;
%page;
new_login: procedure (str,uno,qno);
declare str        character(*) var;
declare uno        bin(31);
declare qno        bin(31);
declare tp         pointer;

     /* LOGIN:  We just got the user's initial request (to login).    */
     /* We'll remember it (so that we can send the proper response),  */
     /* and wait until habitat_db tells us which region to put the    */
     /* user in.                                                      */

     call get_transit_info (qno,tp);
     if (tp = null()) then do;
        if (BUGON) then call trace_msg ('No Transit entry for ' ||
                                        ltrim(uno) || '/' || ltrim(qno));
        return;
        end;

     tp->transit.got_init_request = true;
     tp->transit.login_data       = substr(str,1,12);
     tp->transit.login_request    = substr(str,13);

     call process_login_when_ready (tp->transit.got_db_response,tp);

end new_login;
%page;
process_current_location: procedure (uid,qid,buff,buff_len);
/* params */
declare uid        bin(31);
declare qid        bin(31);
declare buff       pointer;
declare 1 buf_olay       based (buff),
          2 region       bin(31),
          2 current_msg  char(10) var;
declare buff_len   bin(31);
declare tp         pointer;

     call get_transit_info (qid,tp);
     if (tp = null()) then do;
        if (BUGON) then call trace_msg ('No Transit entry for ' ||
                                        ltrim(uid) || '/' || ltrim(qid));
        return;
        end;

     tp->transit.got_db_response = true;
     tp->transit.region_id       = buf_olay.region;
     tp->transit.region_owner    = 0;
     if (buff_len > 4) then
        tp->transit.login_request = buf_olay.current_msg;   /* hatchery sends */

     if (buf_olay.region = -2  &  tp->transit.cc_guide = true)
        then tp->transit.region_id = 0;      /* Override beta tester check. */
     call process_login_when_ready (tp->transit.got_init_request,tp);

end process_current_location;
%page;
process_login_when_ready: procedure (which_condition,tp);
declare which_condition bit(1);
declare tp              pointer;
declare vers   bin(15);
declare vers_str char(2) defined(vers);
declare 1 create_user    ,
          2 sub_account  bin(31),
          2 sub_qid      bin(31),
          2 version      bin(15),
          2 screen_name  char(10),
          2 login_msg    char(10) var;
declare create_message   char(32) defined(create_user);

     if (which_condition = true)
        then if (tp->transit.region_id = 0) then do;
           create_user.sub_account  = tp->transit.avatar;
           create_user.sub_qid      = tp->transit.user_q;
           vers_str                 = substr(tp->transit.login_data,11,2);
           create_user.version      = vers;
           create_user.screen_name  = substr(tp->transit.login_data,1,10);
           create_user.login_msg    = tp->transit.login_request;
           call send_message (newuser_queue, MSG$FIND_CURRENT_REGION,
                             create_message,length(create_message),0,0);
           tp->transit.got_db_response = false;
           end;
        else do;
           call finish_new_login (tp,tp->transit.avatar,tp->transit.user_q);
           call delete_from_list (Transit_list,tp);
           free tp->transit;
           end;

end process_login_when_ready;
%page;
finish_new_login: procedure (tp,uno,qno);
/* params */
declare tp         pointer;
declare uno        bin(31);
declare qno        bin(31);

/* locals */
declare up               pointer;
declare version          bin(15);
declare version_str      character(2) defined(version);
declare uno_str          char(4) defined (uno);


    call get_user_pointer_from_q_id (qno,up);
    if (up ^= null())
       then call reset_user (up->ai_qid, up->ai_uid);

    allocate  avatar_info  set (up);

    up -> ai_uid             = uno;
    up -> ai_account_num     = substr(string(uno),5);
    up -> ai_room_pointer    = null();
    up -> ai_chg_room_ptr    = null();
    up -> ai_room_id         = 0;
    up -> ai_qid             = qno;

    version_str = substr(tp->transit.login_data,11,2);
    up -> ai_version = version;

    call get_unique_screen_name(substr(tp->transit.login_data,1,10),
                                   up->ai_scr_name);
    call compress_name (up->ai_scr_name, up->ai_scr_compname);
    call add_to_avatar_list (up);
    curr_users = curr_users + 1;
    hi_water.users = max(hi_water.users,curr_users);

    call put_user_in_room (uno,qno,tp);

end finish_new_login;
%page;
get_transit_info: procedure (qid,ptr);
declare qid         bin(31);
declare ptr         pointer;
declare le          pointer;
declare done        bit(1);

     le = Transit_list;
     done = false;
     do while (^done & le ^= null());
        ptr = le->le_content;
        le = le->le_next;
        if (ptr->transit.user_q = qid)
              then done = true;
     end ;

     if (^done) then do;
        ptr = null();
        if (BUGON) then call trace_msg ('*ERR - No transit entry for ' || 
                   ltrim(qid));
        end;

end get_transit_info;
%page;
get_unique_screen_name: procedure (name_in,name_out);
/* params */
declare name_in      character(10) varying;
declare name_out     character(10) varying;

    /* 
     * for now we just wont let screen names collide 
     */
    name_out = ltrim(rtrim(name_in));

end get_unique_screen_name;

%page;
get_room_info: procedure (region,p);
declare region bin(31);
declare p      pointer;

declare le   pointer;


     le = region_list;
     do while ( le ^= null() );    /* Do a linear search thru the room list    */
          if (le->le_content->ri_region_id = region)
          then do;                 /* Found the desired room                   */
               p = le->le_content; /* Return the stucture defining the room   */
               return;
               end;
          le = le->le_next;        /* Try the next room                        */
          end;

     /* Didn't find it - we got problems! */

     p = null();

end get_room_info;

%page;
get_room: procedure (region,p,owner,starter);
/* params */
declare region bin(31);
declare p      pointer;
declare owner  bin(31); /* public or private */
declare starter bin(31);

/* locals */
declare le   pointer;


     /* If (the room already exists)
        then
          Return the structure defining the room
        else
          Create a new room and assign it to the first available RoomingHouse
     */

     le = region_list;
     do while ( le ^= null() );    /* Do a linear search thru the room list    */
          if (le->le_content->ri_region_id = region)
          then do;                 /* Found the desired room                   */
               p = le->le_content; /* Return the stucture defining the room   */
               return;
               end;
          le = le->le_next;        /* Try the next room                        */
          end;

     /* Didn't find it - gotta make one           */

     call make_room_make_room(region,p,owner,starter);
     starter = 0;

     end get_room;

%page;
make_room_make_room: procedure (region,p,owner,starter);

/* params */
declare region bin(31);
declare p      pointer;
declare owner  bin(31);
declare starter bin(31);
 
/* locals */
declare le                pointer;
declare rp                pointer;
declare done              bit(1);


    if (balanced_loading) then
         call get_least_busy_room_process (rp);
    else
         call get_first_avail_room_process (rp);

    if (rp = null())
    then do;
         call trace_msg ('ERROR - Failed to get Process for ' || 
                         ltrim(string(region)));
         p = null();
         return;
     end;

    call activate_room (rp,p,region,owner,starter);

end make_room_make_room;
%page;
activate_room: procedure (rpp,rp,region,owner,starter);
/* params */
declare    rpp      pointer;                /* region process pointer */
declare    rp       pointer;                /* region pointer */
declare    region   bin(31);                /* region id */
declare    owner    bin(31);                /* public or private */
declare    starter  bin(31);
declare    region_str char(4) defined(region);

/* locals */
declare   junkp     pointer;
declare   i         bin(15);
declare   pr_flag   character(1); 
declare   room_size bin(15);
declare 1 obuf,                             /*msg format - start room request*/
          2 region_number     bin(31),
          2 who               bin(31),
          2 pr_flag           char(1);
declare obuf_str   char(9) defined(obuf);

declare rq_name     char(32) var;
declare rq_id       bin(31);
declare rq_type     bin(15);

    /*  Take first one from inactive list.  */

    rp = rpp -> rp_inactive_region_list -> le_content;
    rpp -> rp_active_room_count = rpp -> rp_active_room_count + 1;

    call delete_from_list(rpp->rp_inactive_region_list,rp);
    call add_to_list (rpp -> rp_active_region_list,rp);

    how_many_regions_used = how_many_regions_used + 1;
    hi_water.procs = max(hi_water.procs, how_many_regions_used);
    call add_to_list (region_list, rp);

    rp -> ri_region_id      = region;
    rp -> ri_players_online = 0;
    rp -> ri_room_id        = 0;
    rp -> ri_private        = owner;
    rp -> ri_initialized    = false;       /* Must get info from db process. */
    rp -> ri_initialized    = true;
    rp -> ri_enter_list     = null();
    rp -> ri_chg_list       = null();

    if (rp->ri_avatar_list ^= null())
       then call free_userid_list (rp->ri_avatar_list);

    obuf.region_number = region;
    if (owner = -1) 
       then obuf.pr_flag = '*';
       else obuf.pr_flag = ' ';
    obuf.who = starter;

    call send_message (rp->ri_q_pointer, MSG$START_ROOM, obuf_str,
                       9, 0, 0);

    if (BUGON_high) then
       call trace_msg ('Starting region ' || ltrim(region));

end activate_room;
%page;
free_userid_list: procedure (gp);
declare gp     pointer;
declare ptr    pointer;

     do while (gp ^= null());
        ptr = gp->le_content;
        gp = gp->le_next;
        free ptr->user_block;
     end ;

end free_userid_list;
%page;
put_user_in_room: procedure(uid, qid, tp);
     declare uid              bin(31);    /* user  id              */
     declare qid              bin(31);    /* queue id              */
     declare tp               pointer;
     declare up               pointer;
     declare rp               pointer;
     declare p                pointer;
     declare error_msg        char(80) var;
     declare local_uid        bin(31);

     call get_user_pointer_from_q_id(qid, up); /* Find avatar_info struct using Q */
     if (up = null())
     then do;  /* We couldn't find this user      */
          call trace_msg ('*ERR* qid not found '  || ltrim (uid)  ||
                           '/'  ||  ltrim (qid) || ': initial region');
          return;
          end;

     if (tp->transit.region_id <= 0) then do;
          if (tp->transit.region_id = -1) then
             error_msg = 'Club Caribe is temporarily closed.  ' ||
                         'Press Shift-Run/Stop.';
          else if (tp->transit.region_id = -2) then do;
             call trace_msg ('NO AVATAR RECORD: ' || ltrim(string(uid)));
             error_msg = 'NOT a registered Beta Tester.';
             end;
          else error_msg = 'Error - contact Customer Service';
          call respond_to_user (up,tp->transit.login_request,error_msg);
          return;
          end;

     local_uid = uid;
     call get_room(tp->transit.region_id, rp, tp->transit.region_owner, local_uid);

     if (rp = null())
     then do;  /* Tell the micro that the room was full                    */
          call trace_msg ('No more regions!');
          call respond_to_user (up,tp->transit.login_request,
                'Unable to enter Club Caribe - please try again later.');
          return;
          end;

     if (local_uid = 0)
         then up->ai_make_null = false;
         else up->ai_make_null = true;

     call user_to_room(up, rp, tp->transit.login_request);

/*   if (rp->ri_initialized)
RII     then call user_to_room(up, rp, tp->transit.login_request);
        else do;
           allocate new_user set (p);
           p->new_user.uid       = uid;
           p->new_user.qid       = qid;
           p->new_user.region_id = tp->transit.region_id;
           p->new_user.user_data = tp->transit.login_request;
           p->new_user.attempts  = 1;
           call add_to_list (rp->ri_enter_list,p);
           return;
           end;
*/
end put_user_in_room;
%page;
respond_to_user: procedure (up,buff,msg);
declare up     pointer;
declare buff   char(*) var;
declare msg    char(*) var;
declare qp     pointer;

declare enc    char(100) var;

   call open_queue_from_number (up->ai_qid,qp);

   call encode_string (byte(0) || msg,enc);
   call send_message (qp, MSG$NORMAL, substr(buff,1,4) || enc,
                     (length(enc) + 4), up->ai_uid, up->ai_qid);

   call delete_from_avatar_list (up);
   free  up -> avatar_info;
   curr_users = curr_users - 1;

end respond_to_user;
%page;
initialize_region: procedure (buff);
declare buff   pointer;

declare 1 buff_info based(buff),
          2 region_num                  bin(31),
          2 num_ghosts                  bin(15),
          2 num_avatars                 bin(15),
          2 avatar_id(206)              bin(31);

declare i bin(15);
declare rp pointer;
declare tp pointer;
declare ep pointer;

     call get_room_info (region_num, rp);
     if (rp = null()) then do;
        call trace_msg ('Cannot init region ' || string(region_num));
        return;
        end;

     rp->ri_initialized       = true;

     do while (rp->ri_enter_list ^= null());
        call get_from_head_of_list (rp->ri_enter_list,ep);
        call retry_enter_room (ep,rp);
        end;
     do while (rp -> ri_chg_list ^= null());
        call get_from_head_of_list (rp->ri_chg_list,ep);
        call retry_change_room (ep,rp);
        end;

     if (BUGON_high) then
        call trace_msg ('Region init for ' || ltrim(region_num));

end initialize_region;
%page;
add_userid_slot:  procedure (gp,who);
declare gp     pointer;
declare who    bin(31);

declare le     pointer;
declare ptr    pointer;
declare i      bin(15);

     le = gp->ri_avatar_list;
     do while (le ^= null());
        ptr = le->le_content;
        le = le->le_next;
        if (ptr->blk_cnt < user_blk_size) then do i = 1 to user_blk_size;
           if (ptr->user_id(i) = 0) then do;
              ptr->user_id(i) = who;
              ptr->blk_cnt = ptr->blk_cnt + 1;
              return;
              end;
           end;
     end ;

     call prepare_userid_slot (gp,ptr);
     ptr->user_id(1) = who;
     ptr->blk_cnt = ptr->blk_cnt + 1;

end add_userid_slot;
%page;
retry_enter_room: procedure (ep,rp);
declare ep     pointer;
declare rp     pointer;

declare up     pointer;

     if (BUGON) then call trace_msg ('Enter retry for ' || ltrim(ep->new_user.uid));

     call get_user_pointer_from_q_id(ep->new_user.qid, up);
     if (up = null()) then do;            /* User has disconnected... */
        free ep->new_user;                /* ... so just forget him.  */
        return;
        end;

     call user_to_room(up, rp, ep->new_user.user_data);
     free ep->new_user;

end retry_enter_room;
%page;
retry_change_room: procedure(ep,new_rp);
declare ep               pointer;
declare new_rp           pointer;

declare up               pointer;
declare old_rp           pointer;
declare region           bin(31);
declare datap            pointer;

     call get_user_pointer_from_q_id(ep->new_user.qid, up);
     if (up = null()) then do;
        call trace_msg ('Can''t locate user '  ||
                        ltrim (ep->new_user.uid) || ' for changing region.');
        free ep->new_user;
        return;
        end;

     old_rp = up->ai_room_pointer;    /* Get ptr to old region_info struct */

     datap = addrel(addr(ep->new_user.user_data),2);   /* skip 2 for char var */

     /*  Fill in the important parts of q_context .... */

     q_context.uid          = ep->new_user.uid;
     q_context.qid          = ep->new_user.qid;
     q_context.screen_name    = ep->new_user.qc_name;
     call set_context_holding_area (CH$club_caribe, ep->new_user.qc_hold_area);

     call check_new_region (up,datap,new_rp);
     free ep->new_user;

end retry_change_room;

%page;
change_room: procedure(uid, qid, buffer);
     declare uid              bin(31);    /* user  id              */
     declare qid              bin(31);    /* queue id              */
     declare buffer           char(*) var;
     declare up               pointer;
     declare old_rp           pointer;
     declare new_rp           pointer;
     declare region           bin(31);
     declare region_str       char(4) defined(region);
     declare poss_count       bin(15);
     declare poss_count_str   char(2) defined(poss_count);
     declare p                pointer;
     declare ghost_flag       char(1);


     call get_user_pointer_from_q_id(qid, up); /* Find avatar_info struct using Q */
     if (up = null())
     then do;  /* We couldn't find this user      */
          call trace_msg ('*ERR* Chg reg null user ptr '  ||
                          ltrim (uid)  ||  '/'  ||  ltrim (qid) || ':' || buffer);
          return;
          end;

     if ( (up->ai_uid ^= uid) | (up->ai_qid ^= qid) )
     then do;  /* I think this says we got the WRONG user   */
          call trace_msg ('*ERR* WRONG user '  ||
                          ltrim (uid)  ||  '/'  ||  ltrim (qid) || ':' || buffer);
          return;
          end;

     old_rp = up->ai_room_pointer;      /* Get ptr to old region_info struct */
     if (old_rp = null())
     then do;  /* Found the user, but we think he's not in any room yet        */
          call trace_msg ('*ERR* user has no room '  ||
                          ltrim (uid)  ||  '/'  ||  ltrim (qid) || ':' || buffer);
          return;
          end;
%page;

     region_str     = substr(buffer,1,4);
     poss_count_str = substr(buffer,5,2);
     ghost_flag     = substr(buffer,7,1);

     if (BUGON_high) then
        call trace_msg (ltrim(uid) || ': Request change to region ' ||
                        ltrim(region));

     if (up->ai_chg_room_ptr ^= null()) then do;
        call trace_msg ('Chg region discarded for ' ||
                        ltrim(uid) || ' region: ' || ltrim(region));
        return;
        end;

     up->ai_make_null = false;
     if (region ^= -1)
        then call get_room(region, new_rp, public$room, 0);

     if (region = -1  |  new_rp = null()) then do;
        call send_message(old_rp->ri_q_pointer, MSG$CHANGE_ROOM_FAILED,
                               '', 0, uid, qid);
        if (region ^= -1) then 
           call trace_msg ('NO MORE REGION SLOTS.');
        return;
        end;

     if (new_rp->ri_initialized)
        then call check_new_region(up, addrel(addr(buffer),2), new_rp);
        else do;
          allocate new_user set (p);
          p->new_user.uid         = uid;
          p->new_user.qid         = qid;
          p->new_user.region_id   = region;
          p->new_user.qc_name     = q_context.screen_name;
          p->new_user.qc_hold_area = get_context_holding_area (CH$club_caribe);
          p->new_user.user_data   = buffer;
          call add_to_list (new_rp->ri_chg_list,p);
          return;
          end;

end change_room;
%page;
check_new_region: procedure (up, datap, new);
declare up     pointer;
declare datap  pointer;
declare new    pointer;
declare tp     pointer;

declare 1 request             based,
          2 region_num        bin(31),
          2 total_cnt         bin(15),
          2 ghost_flag        char(1),
          2 unused            char(1),
          2 objs(9)           bin(15),
          2 pos(9)            bin(15);
declare request_str           char(1) based;

     call send_message(new->ri_q_pointer, MSG$USER_ENTER_ROOM,
                       datap->request_str,bytesize(request),
                       up->ai_uid,up->ai_qid);

/* Update players_online  - assume the change_region will go through. */

     up->ai_chg_room_ptr = new;
     new->ri_players_online = new->ri_players_online + 1;
     call add_userid_slot (new,up->ai_uid);

end check_new_region;
%page;
check_change_result: procedure(uid,qid,ptr,msg_len);
declare uid         bin(31);
declare qid         bin(31);
declare ptr         pointer;
declare msg_len     bin(31);

declare up          pointer;
declare room        pointer;
declare 1 result    based(ptr),
          2 code    bin(15),
          2 roomq   bin(31),
          2 rproc   bin(15);
declare result_str  char(2) based(ptr);

    call get_user_pointer_from_q_id(qid, up);
    if (up = null()) then do;
       call trace_msg ('*ERR* unable to locate '  || ltrim(uid) ||
                       ', check chg result.');
       return;
       end;
    if (up->ai_chg_room_ptr = null()) then do;   /* => Regionproc crash */
       call trace_msg ('Chg result discarded (crash?): '  || ltrim(uid));
       return;
       end;

    room = up->ai_room_pointer;
    if (BUGON_high) then
       call trace_msg (ltrim(uid) || ':  Chg result of ' || ltrim(result.code));
    call send_message(room->ri_q_pointer, MSG$CHANGE_ROOM_RESULT, result_str,
                            msg_len,uid,qid);

    if (result.code ^= 1) then do;                /* Change has PASSED. */
       call drop_user_from_room(up,room);
       up->ai_room_pointer = up->ai_chg_room_ptr;
       up->ai_room_id      = up->ai_room_pointer->ri_region_id;
       up->ai_chg_room_ptr = null();
       end;
    else do;                                      /* Change has FAILED. */
       call drop_user_from_room(up,up->ai_chg_room_ptr);
       up->ai_chg_room_ptr = null();
       end;

end check_change_result;
%page;
pass_to_new_region: procedure (arg,msgtype,msglen,uid,qid);
declare arg    pointer;
declare msgtype bin(31);
declare msglen bin(31);
declare uid    bin(31);
declare qid    bin(31);
declare up     pointer;
declare new_region pointer;

declare 1 info based(arg),
          2 regionq      bin(31),
          2 pass_thru    char(1020);

     call open_queue_from_number(regionq,new_region);
     call send_message (new_region,msgtype,substr(info.pass_thru,1,msglen-4),
                        msglen-4, uid,qid);

end pass_to_new_region;
%page;
user_to_room: procedure(user, room, init_request);
     declare user             pointer;
     declare room             pointer;
     declare init_request     character(*) var;

     declare 1 entry_info     ,
               2 version      bin(15),
               2 dashes       char(2),
               2 user_name    char(10),
               2 first_req    char(10);
     declare str character(24) defined (entry_info);

     declare 1 null_region    ,
               2 null_value   bin(31),
               2 count        bin(15),
               2 who          bin(31);
     declare null_region_msg char(10) defined(null_region);

     if (user->ai_room_pointer ^= null())
     then do;  /* Should always have left old room before this is called   */
          call trace_msg ('*ERR* "user_to_room" called with user in a room '  ||
                          ltrim (user->ai_uid)  ||  '/'  ||  ltrim (user->ai_qid));
          return;
          end;

     entry_info.version   = user->ai_version;
     entry_info.dashes    = '--';
     entry_info.user_name = user->ai_scr_name;
     entry_info.first_req = init_request;
     call send_message(room->ri_q_pointer, MSG$USER_ENTER_ROOM, str,
                       length(init_request)+14,user->ai_uid,user->ai_qid);

     if (user->ai_make_null = true) then do;
          null_region.null_value = NULL_REGION;
          null_region.who = user->ai_uid;
          null_region.count = 1;
          call set_context_holding_area (CH$club_caribe, ' ');
          call send_message (habitat_db_queue, MSG$CKPOINT_MY_REGION,
                       null_region_msg, 10, 0, habitat_qid);
          user->ai_make_null = false;
          end;

     user->ai_room_pointer   = room;
     user->ai_room_id        = room->ri_region_id;
     room->ri_players_online = room->ri_players_online + 1;
     call add_userid_slot (room,user->ai_uid);

end user_to_room;
%page;
leave_room: procedure (u,r);
     declare u pointer;
     declare r pointer;

    /*
     *            *********DANGER********
     * some mechanism is going to be needed to assure that 
     * the room the dolt leaves sends off all the old messages
     * before the new room sends off any messages
     *
     * is this message needed? after all it was the room who told us
     * the guy was leaving.  I dont think so, but leave it in for now.
     */

     call send_message (r -> ri_q_pointer, MSG$USER_LEAVE_ROOM,
                       '', 0, u -> ai_uid, u -> ai_qid);
             
     call drop_user_from_room(u,r);
   
     u->ai_room_id      = 0;
     u->ai_room_pointer = null();

end leave_room;

%page;
region_process_woke_up: procedure (data);
declare data        char(*);

declare proc_index  binary(15) defined (data);

/* locals */
declare nu_rume     pointer;
declare who_cares   pointer;
declare j           bin(15);
declare i           bin(15);
declare bi_15_junk  bin(15);
declare ch_junk     character(32) varying;

declare new_proc_p  pointer;
declare 1 new_proc  like region_process_info based (new_proc_p);

     if (proc_index <= 0  |  proc_index > max_regionprocs) then do;
          call trace_msg ('Invalid regionproc index: ' || ltrim (proc_index));
          return;
          end;

     new_proc_p     = region_proc_list (proc_index);

     if (new_proc.rp_active_room_count >= 0) then do;
          /* This process was already active - must have crashed */
          call trace_msg ('region.' || ltrim (proc_index) || ' has reset');

          call cleanup_hung_regions (new_proc_p);
          return;
          end;

     block_users                        = false;
     new_proc.rp_number                 = proc_index;
     new_proc.rp_active_room_count      = 0;
     new_proc.rp_active_region_list       = null ();
     new_proc.rp_inactive_region_list     = null ();

     do i = 1 to REGIONS_PER_PROCESS;
          allocate  region_info  set (nu_rume);
          call add_to_list (new_proc.rp_inactive_region_list,nu_rume);
          nu_rume->ri_q_pointer = null();
          nu_rume->ri_poppa     = new_proc_p;
          call make_sub_sender_queue ('region_big.' 
                                || ltrim(new_proc.rp_number),
                                max_events + new_proc.rp_number,
                                nu_rume -> ri_q_pointer,i );

          nu_rume->ri_room_id         = 0;
          nu_rume->ri_players_online  = 0;

          call GetQueueInformation(nu_rume -> ri_q_pointer,
                                 ch_junk, 
                                 nu_rume -> ri_q_id, 
                                 bi_15_junk);
          nu_rume->ri_avatar_list = null();
          call prepare_userid_slot (nu_rume, who_cares);
          end;      /* i = 1 to max_rooms         */

     new_proc.rp_pointer         = nu_rume->ri_q_pointer;
     RegionQ(new_proc.rp_number) = nu_rume->ri_q_pointer;
 
end region_process_woke_up;
%page;
get_first_avail_room_process: procedure (rp);
     declare rp     pointer;       /* Returned pointer to room process       */

     declare n      binary(15);

     do n = 1 to max_regionprocs;
          rp = region_proc_list (n);

          if (rp->rp_active_room_count >= 0  &  
              rp->rp_active_room_count < REGIONS_PER_PROCESS)
          then   /* This region(i) has rooms - its the one we want */
               return;
          end;

     rp   = null ();

end get_first_avail_room_process;
%page;
get_least_busy_room_process: procedure (rp);
     declare rp     pointer;       /* Returned pointer to room process       */

     declare rptr   pointer;
     declare n      binary(15);
     declare min    bin(15);    /* Tracks least number of rooms in use      */


     /* Assign this new room to the region(i) with the LEAST number of
     /* active rooms, if there is one with any room remaining.  If region(i)
     /* have the same number of filled rooms, the algorithm will add rooms
     /* in the order the region(i)s were created (1,2,3,4).
     */

     min = REGIONS_PER_PROCESS;
     rp  = null ();

     do n = 1 to max_regionprocs;
          rptr = region_proc_list (n);

          if (rptr->rp_active_room_count >= 0  &  
              rptr->rp_active_room_count < min)
          then do;  /* This region(i) has rooms and is best found so far   */
               rp  = rptr;
               min = rptr->rp_active_room_count;
               end;
          end;

end get_least_busy_room_process;

%page;
get_user_pointer_from_q_id: procedure (qid,p);
/* params */
declare qid bin(31);
declare p  pointer;
/* locals */
declare le pointer;
declare i  bin(15);

    call hash_by_qid (qid,i);
    le = avatar_list(i);
    p = null();

    do while (le ^= null() );
       if (le -> le_content -> ai_qid = qid)
       then do;
           p = le -> le_content;
           return;
       end;
       le = le -> le_next;
    end;

end get_user_pointer_from_q_id;
%page;
get_user_pointer_from_uid: procedure (uid,p);
/* params */
declare uid bin(31);
declare p  pointer;
/* locals */
declare le pointer;
declare i  bin(15);
declare uid_str char(10);

    uid_str = substr(string(uid),5);
    call hash_by_acct (uid_str,i);
    le = avatar_list(i);
    p = null();

    do while (le ^= null() );
       if (le -> le_content -> ai_uid = uid)
       then do;
           p = le -> le_content;
           return;
       end;
       le = le -> le_next;
    end;

end get_user_pointer_from_uid;
%page;
reset_user: procedure (q, user);

/* params */
declare   q        bin(31);
declare   user     bin(31);

/* locals */
declare le         pointer;
declare found      bit(1);
declare roomp      pointer;
declare up         pointer;
declare i          bin(15);
declare tp         pointer;
declare need_dump  bit(1) aligned;

    need_dump = false;
    call get_transit_info (q,tp);
    if (tp ^= null()) then do;
        call delete_from_list (Transit_list,tp);
        free tp->transit;
        need_dump = true;
        end;

    call get_user_pointer_from_q_id (q,up);
    if (up = null()) then do;
       if (^need_dump) then
            call trace_msg ('Unable to find unplugged user');
       return;
       end;

/*    if (need_dump) then call aborted_load_dump (up); */

    if (up->ai_room_id = 0) then do;    /* Was on during regionproc crash */
       call delete_from_avatar_list (up);
       curr_users = curr_users - 1;
       return;
       end;

    roomp = up -> ai_room_pointer;
    if (roomp ^= null()) then do;
       call send_message (roomp->ri_q_pointer, MSG$USER_UNPLUGGED,
                              '',0,up->ai_uid,q);
       call drop_user_from_room(up,roomp);
       end;

    roomp = up -> ai_chg_room_ptr;
    if (roomp ^= null()) then do;
       call send_message (roomp->ri_q_pointer, MSG$USER_UNPLUGGED,
                              '',0,up->ai_uid,q);
       call drop_user_from_room(up,roomp);
       end;

    call delete_from_avatar_list (up);
    curr_users = curr_users - 1;

end reset_user;
%page;
drop_user_from_room: procedure(u,r);
     declare u           pointer;  /* Pointer to the avatar_info structure   */
     declare r           pointer;  /* Pointer to the region_info structure   */
     declare rp          pointer;  /* Pointer to region_process_info struct  */
     declare le          pointer;
     declare tp          pointer;
     declare i           bin(15);
     declare max_size    bin(15);
     declare done        bit(1);


     if (r = null()) then do;
          call trace_msg ('Drop user from null room: ' || ltrim(u->ai_uid));
          return;
          end;

     rp = r->ri_poppa;        /* Get the PROCESS holding this ROOM    */
     r->ri_players_online = r->ri_players_online - 1;

     le = r->ri_avatar_list;
     done = false;
     do while (le ^= null()  &  ^done);
        tp = le->le_content;
        do i = 1 to user_blk_size while (^done);
           if (tp->user_id(i) = u->ai_uid) then do;
               tp->user_id(i) = 0;
               tp->blk_cnt = tp->blk_cnt - 1;
               done = true;
               if (tp->blk_cnt = 0) then do;
                  call delete_from_list (r->ri_avatar_list,tp);
                  free tp->user_block;
                  end;
               end;
           end;
        if (^done) then le = le->le_next;
        end;

     if (^done) then
        call trace_msg ('Drop from region ' || ltrim(r->ri_region_id) ||
                        ' did not find ' || ltrim(u->ai_uid));

     if (r->ri_players_online <= 0) then call ReCycleRoom(r);

end drop_user_from_room;
%page;
aborted_load_dump: procedure (up);
declare up  pointer;
declare qp  pointer;

/*
   call open_queue_from_number (up->ai_qid,qp);
   if (qp = null()) then return;

   call send_message(qp, MSG$DUMP_CIRCULAR,byte(32),1,up->ai_uid, up->ai_qid);
*/
   call info_trace_msg ('Load dump for ' || up->ai_scr_name);

end aborted_load_dump;
%page;
find_by_name:  procedure (buf, uid, qid);
declare buf         character(*) varying ;
declare uid         binary(31) ;
declare qid         binary(31) ;

declare up          pointer;
declare qp          pointer;
declare user_que    pointer;

declare 1 list_buffer ,
          2 list_name         character(10),
          2 list_uid          binary(31),
          2 list_qid          binary(31),
          2 list_version      binary(15);
declare list_buff        character(20) defined(list_buffer) ;


     call get_user_pointer_from_q_id (qid, up);
     if (up = null ())  then  return;

     qp = up->ai_room_pointer->ri_q_pointer;

     list_name = buf;
     call get_acct_info (list_name,list_uid,list_qid,list_version,user_que);
     call send_message (qp, MSG$FOUND_ID, list_buff,20,uid,qid) ; 
 
end find_by_name;
%page;
send_olm_msg: procedure(bptr,uid,qid);
declare bptr   pointer;
declare uid    bin(31);
declare qid    bin(31);
declare vers   bin(15);
declare rp     pointer;
declare 1 buff based(bptr),
          2 addressee    char(10),
          2 from_name    char(10),
          2 message      char(117) var;
declare 1 result,
          2 msg_uid      bin(31),
          2 msg_qid      bin(31),
          2 msg_from     char(10),
          2 msg_text     char(117) var;
declare result_str char(1) defined(result);

  call get_acct_info (buff.addressee,msg_uid,msg_qid,vers,rp);
  if (rp = null()) then return;

  result.msg_from = buff.from_name;
  result.msg_text = buff.message;
  call send_message (rp, MSG$HABITAT_OLM, result_str,length(msg_text)+20,0,0);
  return;

end send_olm_msg;
%page;
get_acct_info:  procedure (a_name,a_uid,a_qid,a_version,a_regionptr);
declare a_name      char(10);
declare a_uid       bin(31);
declare a_qid       bin(31);
declare a_version   bin(15);
declare a_regionptr pointer;
declare i           binary(15) ;
declare p           pointer ;
declare qp          pointer ; 
declare le          pointer ; 
declare (name_in,name_out) character(10) varying;
declare str_name    character(10) ;

     name_in = a_name;
     call compress_name(name_in,name_out);
     str_name = name_out;
     call hash_by_name (str_name,i) ;
     le = avatar_list (i) ;
     
     a_qid     = 0;
     a_uid     = 0;
     a_version = 0;
     a_regionptr = null();

     do while (le ^= null()) ;
          p = le->le_content ;
          if  (p->ai_scr_compname = name_out)
          then do ;                                                   
               a_qid = p->ai_qid ;
               a_version = p->ai_version;
               if (p->ai_room_pointer = null())
                  then a_regionptr = null();
                  else if (p->ai_chg_room_ptr ^= null())
                     then a_regionptr = null();
                     else a_regionptr = p->ai_room_pointer->ri_q_pointer;
               if (a_regionptr = null())
                  then a_uid = 0;
                  else a_uid = p->ai_uid ;
               return ;
          end ;
          else do ;
               le = le->le_next ; 
          end ;
     end ;
     
     return;
 
end get_acct_info;
%page;
signal_mail_arrival: procedure(bptr,uid);
declare bptr   pointer;
declare uid    bin(31);
declare 1 buff based(bptr),
          2 flag         bin(15),
          2 postmark     bin(31);

declare up     pointer;
declare roomp  pointer;

declare char_buf char(6) defined(buff);

   call get_user_pointer_from_uid (uid,up);
   if (up = null()) then return;        /* not online, so forget it. */

   roomp = up -> ai_room_pointer;
   if (roomp ^= null())
      then call send_message (roomp->ri_q_pointer, MSG$MAIL_ARRIVED,
                             char_buf,6, up->ai_uid,0);
      else call trace_msg ('Null room for user ' || ltrim(up->ai_uid) ||
                           ' for mail delivery.');

end signal_mail_arrival;
%page;
list_latest_users: procedure(match_name, uid);
declare match_name char(*) var;
declare uid        bin(31);

declare up         pointer;
declare qp         pointer;
declare le         pointer;
declare last_buff  char(1) defined (last_login.pos);

declare i          bin(15);
declare match_len  bin(15);
declare more       bit(1) aligned;

   call get_user_pointer_from_uid (uid,up);
   if (up = null()) then return;        /* not online, so forget it. */

   i = 1;
   more = true;
   le = linear_avatar_list;
   match_len = length(match_name);

   do while (more);
      qp = le->le_content;
      le = le->le_next;
      if (match_len = 0  |  
      substr(qp->ai_scr_name,1,match_len) = match_name) then do;
         last_login.name(i) = qp->ai_scr_name;
         i = i + 1;
         if (i = 12) then more = false;
         end;
      if (le = null()) then more = false;
      end;
   last_login.pos = i - 1;

   qp = up->ai_room_pointer->ri_q_pointer;
   call send_message (qp, MSG$USER_STATS, last_buff,122,uid,up->ai_qid) ; 
   return;

end list_latest_users;
%page;
prepare_userid_slot: procedure (rp,tp);
declare rp     pointer;
declare tp     pointer;
declare i      bin(15);

   allocate user_block set (tp);
   call add_to_list (rp->ri_avatar_list,tp);

   tp->blk_cnt  = 0;

   do i = 1 to user_blk_size;
      tp->user_id(i) = 0;
      end;

end prepare_userid_slot;
%page;
reroute_message:  procedure (buf, uid, qid);
declare buf         character(*) varying;
declare uid         binary(31);
declare qid         binary(31);

declare up          pointer;
declare roomp       pointer;

   call get_user_pointer_from_q_id (qid,up);
   if (up = null()) then do;
      if (BUGON) then 
         call trace_msg ('Unable to find ' || ltrim(uid) ||
                         ' for message rerouting');
      return;
      end;

   roomp = up -> ai_room_pointer;
   call send_message(roomp->ri_q_pointer, MSG$TERMINAL_MESSAGE,
                     substr(buf,1),length(buf),up->ai_uid,up->ai_qid);
   return;

end reroute_message;
%page;
ReCycleRoom: procedure (rp);
     declare rp          pointer;
     declare i           bin(15);
     declare pops        pointer;

     if (BUGON_high) then 
        call trace_msg ('Region ' || ltrim(rp->ri_region_id) || ' removed.');

     pops = rp->ri_poppa;

     rp->ri_players_online  = 0;
     rp->ri_initialized     = false;
     if (rp->ri_enter_list ^= null()) then do;
         rp->ri_enter_list = null();
         call trace_msg ('Recycle with enter list for ' || 
                            ltrim(rp->ri_region_id));
         end;
     if (rp->ri_chg_list ^= null()) then do;
         rp->ri_chg_list = null();
         call trace_msg ('Recycle with change list for ' || 
                            ltrim(rp->ri_region_id));
         end;
     rp->ri_region_id = 0;

     if (rp->ri_avatar_list ^= null())
         then call free_userid_list (rp->ri_avatar_list);

    call delete_from_list (region_list,rp);  
    call delete_from_list (pops -> rp_active_region_list, rp);
    call add_to_list (pops -> rp_inactive_region_list, rp);    

    pops->rp_active_room_count = pops->rp_active_room_count-1;
    how_many_regions_used        = how_many_regions_used-1;

end ReCycleRoom; 
GetInsideAddress: procedure (qid,qp);

/* params */
declare qid     bin(31);
declare qp      pointer;
 
/* locals */
declare up      pointer;

    call get_user_pointer_from_q_id (qid,up);

    /*
     * ****** DANGER ******
     * how can up be null?  i dont have time now to find out, avoid it.
     */
    if (up ^= null())
    then do;
         qp = up -> ai_room_pointer -> ri_q_pointer;
    end;
    else do 
         qp = null();
    end;

end GetInsideAddress;
%page;
add_to_avatar_list: procedure (p);
declare p           pointer;
declare i1          bin(15);
declare i2          bin(15); 
declare i3          bin(15);
declare str_name    character(10);
declare code        bin(15);

     str_name = p->ai_scr_compname; 
     call hash_by_name (str_name,i1);
     call add_to_list (avatar_list(i1),p);
     call hash_by_acct (p->ai_account_num,i2);
     if (i1 ^= i2) then call add_to_list (avatar_list(i2),p);
     call hash_by_qid (p->ai_qid,i3);                   
     if ((i1 ^= i3) & (i2 ^= i3)) then call add_to_list (avatar_list(i3),p);
     call add_to_list (linear_avatar_list,p);

end add_to_avatar_list;
%page;
delete_from_avatar_list: procedure (p);
declare p           pointer;
declare i1          bin(15);
declare i2          bin(15);
declare i3          bin(15);
declare str_name    character(10);
declare code        bin(15);

     str_name = p->ai_scr_compname; 
     call hash_by_name (str_name,i1);
     call delete_from_list (avatar_list(i1),p);
     call hash_by_acct (p->ai_account_num,i2);
     if (i1 ^= i2) then call delete_from_list (avatar_list(i2),p);
     call hash_by_qid (p->ai_qid,i3);
     if ((i1 ^= i3) & (i2 ^= i3)) then call delete_from_list (avatar_list(i3),p);
     call delete_from_list (linear_avatar_list,p);

end delete_from_avatar_list;
%page;
hash_by_name: procedure (str,i);
declare str         character(*);
declare i           bin(15);
declare str1        character(10) defined(bin_flds);
declare 1 bin_flds,
          2    bin1      bin(15),
          2    bin2      bin(31),
          2    bin3      bin(31);

     str1 = str;
     i = mod(bin1+bin2+bin3,hash_value) + 1;
 
end hash_by_name; 

hash_by_acct: procedure (str,i);
declare str         character(*);
declare i           bin(15);
declare str1        character(10) defined(bin_flds);
declare 1 bin_flds,
          2    bin1      bin(15),
          2    bin2      bin(31),
          2    bin3      bin(31);

     str1 = str;
     i = mod(bin1+bin2+bin3,hash_value) + 1;
 
end hash_by_acct;

hash_by_qid: procedure (qid,i); 
declare qid         bin(31); 
declare i           bin(15);

     i = mod(qid,hash_value) + 1;

end hash_by_qid;
%page;

cleanup_hung_regions: procedure (pops);
declare pops   pointer;
declare regn   pointer;
declare le     pointer;
declare i      binary(15);

   le = pops->rp_active_region_list;
   do i = 1 to pops->rp_active_room_count;
      regn = le->le_content;
      le = le->le_next;
      if (regn ^= null()) then do;
         call cleanup_hung_users (regn);
         call ReCycleRoom (regn);
         end;
      end;

   pops->rp_active_room_count = 0;
      
end cleanup_hung_regions;
%page;
cleanup_hung_users: procedure (rp);
declare rp pointer;
declare up pointer;
declare gp pointer;
declare i  binary(15);
declare le pointer;
declare lp pointer;

declare 1 reset,
          2 current_region    bin(31),
          2 num_players       bin(15),
          2 player_id(254)    bin(31);
declare reset_msg char(1) defined(reset);

   reset.current_region = rp->ri_region_id;
   reset.num_players    = 0;

   le = rp->ri_avatar_list;
   do while (le ^= null());
      lp = le->le_content;
      do i = 1 to user_blk_size;
         if (lp->user_id(i) ^= 0) then do;
            call get_user_pointer_from_uid (lp->user_id(i),up);
            if (up ^= null()) then do;
               up->ai_room_pointer = null();
               up->ai_room_id      = 0;
               call add_to_reset_msg;
               end;
            end;
         end;
      le = le->le_next;
      end;

   do while (rp->ri_enter_list ^= null());
      call get_from_head_of_list (rp->ri_enter_list,gp);
      call get_user_pointer_from_q_id (gp->new_user.qid,up);
      if (up ^= null()) then do;
         up->ai_room_pointer = null();
         up->ai_room_id      = 0;
         call add_to_reset_msg;
         end;
      free gp->new_user;
      end;

   do while (rp->ri_chg_list ^= null());
      call get_from_head_of_list (rp->ri_chg_list,gp);
      call get_user_pointer_from_q_id (gp->new_user.qid,up);
      if (up ^= null()) then do;
         call send_message(up->ai_room_pointer->ri_q_pointer,
                   MSG$CHANGE_ROOM_FAILED,'', 0, up->ai_uid, up->ai_qid);
         up->ai_chg_room_ptr = null();
         end;
      free gp->new_user;
      end;

   if (reset.num_players = 0) then return;

   call send_message (habitat_db_queue, MSG$CKPOINT_MY_REGION, reset_msg,
                      ((reset.num_players*4)+6), 0, habitat_qid);
   return;

add_to_reset_msg: procedure;

   reset.num_players = reset.num_players + 1;
   reset.player_id(reset.num_players) = up->ai_uid;

   if (reset.num_players = 254) then do;
      call send_message (habitat_db_queue, MSG$CKPOINT_MY_REGION, reset_msg,
                      ((reset.num_players*4)+6), 0, habitat_qid);
      reset.num_players = 0;
      end;

end add_to_reset_msg;
end cleanup_hung_users;

%page;
Stat_Flush: procedure;
declare   rp   pointer;
declare   le   pointer;

     le = region_process_list;
     do while (le ^= null());
          rp = le->le_content;
          call send_message (rp->rp_pointer, MSG$STATFLUSH, '',0,0,0);
          le = le->le_next;
     end;
         
end Stat_Flush;
%page;
calculate_today_start:  procedure (ptr);
declare  ptr        pointer;

declare  code       binary(15);
declare  cur_time   binary(31);
declare  wait_time  binary(31);
declare  date_stg   char(32) var;
declare  today_start_time bin(31);

   call s$int_date_time (cur_time);
   call s$cv_to_string_date_time (cur_time, date_stg);
   call s$cv_to_int_date_time (substr (date_stg, 1, 8), today_start_time, code);
   if (code ^= 0)  then  call debug_msg (code, date_stg);


/*    today is defined as starting at 10:00 am */
/*    reset this value each day    at 10:00 am */

   today_start_time = today_start_time - (14*60*60); /* previous day at 10:00 am */

   if (cur_time - today_start_time  >=  24*60*60)  then  /* after 10:00 am ?  */
       today_start_time = today_start_time + 24*60*60;   /* today at 10:00 am */

   wait_time = 24*60*60 - (cur_time - today_start_time);

   call Tact (calculate_today_start, null (), wait_time); /* wake up tomorrow */

   if (hi_water.users > 0) then do;
      call info_trace_msg ('HIGH:  users = ' || ltrim(hi_water.users) ||
                           ', regions = ' || ltrim(hi_water.procs));
      hi_water.users = 0;
      hi_water.procs = 0;
      keep_cnt       = 0;
      end;

end  calculate_today_start;
%page;
process_console_msg: procedure (buff);
declare buff                  character(*) varying;
declare len                   bin(31);
declare rp                    pointer;
declare le                    pointer;
declare type                  bin(31);

     len = length(buff);
     if substr(buff,1,1) = 'Q' then do;
        type = MSG$FLUSH_Q_STATS;
        len = len - 1;
        substr(buff,1,1) = substr(buff,2,1);
     end;
     else do;
        type = MSG$DEBUG_MSG;
     end;

     le = region_process_list;
     do while (le ^= null());
          rp = le->le_content;
          call send_message (rp->rp_pointer,type,
                              substr(buff,1),len,0,0);
          le = le->le_next;
     end;

     if type = MSG$DEBUG_MSG then call debug_on (substr(buff,1),len); 

end process_console_msg;
%page;

initialize_process: procedure;
declare code             binary(15);
declare i                binary(15);
declare junk             binary(31);
declare my_name          char(32) var;

   call s$parse_command ('habitat master', code,
                         'option(-max_regionprocs),number,=3', max_regionprocs,
                         'option(-system),string,=quantum.quantum',whos_system,
                         'switch(-subsys_log),=1', habitat_log,
                         'switch(-balanced),=1',  balanced_loading,
                         'switch(-restart),=0',   restarting,
                         'end');
   if (code ^= 0) then stop;

   if (habitat_log)
      then call set_debug_queue ('habitat_debug');

   call initialize_queues_and_tasks ('habitat', habitat_queue,
                                     max_events + max_regionprocs,
                                     obn_event, tact_event);
   call GetQueueInformation (habitat_queue, my_name, habitat_qid, code);
   call make_server_queue ('habitat_big', serverQ_event, habitatQ_queue, junk);

   call make_sender_queue ('habitat_db', db_event,      habitat_db_queue);
   call make_sender_queue ('hatchery',   newuser_event, newuser_queue);

   call init_stats (stat_event);

   last_login.pos = 0;

   if (restarting) then
      call crash_all_regionprocs;

   do i = 1 to max_regionprocs;
      allocate  region_process_info   set (region_proc_list (i));
      region_proc_list (i)->rp_active_room_count = -1;
      end;

   call calculate_today_start (null());

end initialize_process;
%page;

process_internal: procedure (cmd);
     declare cmd    char(*)var;

     declare n      binary(15);
     declare m      binary(15);
     declare pp     pointer;

     if (cmd ^= 'procs') then do;
          call trace_msg ('Unknown internal command "' || cmd || '"');
          return;
          end;

     do n = 1 to max_regionprocs;
          pp   = region_proc_list (n);
          if (pp->rp_active_room_count < 0) then
               put list ('region.' || ltrim (n) || ' is not running');
          else if (pp->rp_active_room_count = 0) then
               put list ('region.' || ltrim (n) || ' is running, but is idle');
          else 
               put list ('region.' || ltrim (n) || ' is running, and has ' ||
                       ltrim (pp->rp_active_room_count) || ' active regions');

          put skip;
          end;

end process_internal;
%page ;

crash_all_regionprocs: procedure;
     declare n           binary(15);
     declare qlink_dir   char(256)var;
     declare code        binary(15);

     /* NOTE - we have to use the tool oriented send message here since */
     /* we may try to send messages to regionprocs that don't exist and */
     /* the standard Kernel routines would hang waiting for the queue.  */

     call s$get_current_dir (qlink_dir);

     do n = 1 to max_regionprocs;
          call send_msg_to_queue (qlink_dir, 'region.' || ltrim (n),
                                  MSG$DEBUG_MSG, 'stop_processhabitat', 
                                  code);
          if (code ^= 0  &
              code ^= e$object_not_found     &
              code ^= e$no_msg_server_for_queue) then
               call debug_msg (code, 'killing region.' || ltrim (n));
          end;

     /* The following is here to force the lib routine to close last queue */
     call send_msg_to_queue (qlink_dir, byte (0), -1, '', code);

end crash_all_regionprocs;
