%nolist; %include 'cc_sys_defs.incl.pl1';         %list;
%nolist; %include 'cc_message_defs.incl.pl1';     %list;
%nolist; %include 'cc_messages_dcls.incl.pl1';    %list;

%replace MB$threshold by 320;         /* in bits (40 bytes) */
%replace MB$chunk_size by 40;         /* in bytes, but same as threshold */

%replace wait_forever                   by     -1;
%replace Separation_Char                by    144;
%replace e$invalid_eventid              by   1183;

%replace reg_msg_size                   by    256;
%replace big_msg_size                   by   1024;
%replace obj_fixed                      by     26;

declare  ascii_qid             entry (bin(31)) returns (char(10) var);
declare  compress_name         entry (char(*) var, char(*) var);
declare  hex                   entry (bin(31), bin(15)) returns (char(8) var);
declare  open_file             entry (char(*)var, bin(15), bin(15), bin(15),
                                      bin(15), bin(15), bin(15), char(*)var,
                                      bin(15));

declare  s$allocate            entry (bin(31), pointer);
declare  s$close               entry (bin(15), bin(15));
declare  s$create_keep_module  entry (char(256) var, pointer, bin(15));
declare  s$cv_to_int_date_time entry (char(*)var, bin(31), bin(15));
declare  s$cv_to_string_date_time
                               entry (bin(31), char(32)var);
declare  s$detach_port         entry (bin(15), bin(15));
declare  s$expand_path         entry (char(256) var, char(32) var, 
                                      char(256) var, bin(15));
declare  s$free                entry (pointer);
declare  s$get_process_id      entry (bin(31));
declare  s$int_date_time       entry (bin(31));
declare  s$parse_command       entry (char(*)var, bin(15),
                                      char(*)var, char(*)var,
                                      char(*)var, bit(1) aligned, char(*)var);
declare  s$seq_read            entry (bin(15), bin(15), bin(15), char(*), 
                                      bin(15));
declare  s$task_setup_wait     entry (bin(31), bin(15), bin(15), bin(31),
                                      bin(31), bin(31), bin(15), bin(15));
declare  s$task_wait_event     entry (bin(31), bin(31), bin(15), bin(31),
                                     bin(15), bin(31), bin(31), bin(15));


%nolist;  %include 'Messages.incl.pl1';        %list;
%nolist;  %include 'Queues.incl.pl1';          %list;
%nolist;  %include 'Debug.incl.pl1';           %list;
%nolist;  %include 'Lists.incl.pl1';           %list;
%nolist;  %include 'Lists.strux.incl.pl1';     %list;
%nolist;  %include 'TimeAfterTime.incl.pl1';   %list;
%nolist;  %include 'Stat.strux.incl.pl1';      %list;
%nolist;  %include 'Context_defs.incl.pl1';    %list;
%nolist;  %include 'messages.strux';           %list;

%nolist;  %include 'cc_class_defs.incl.pl1';   %list;

%nolist;  %include 'cc_sys_strux.incl.pl1';    %list;
%nolist;  %include 'cc_class_dcls.incl.pl1';   %list;
%nolist;  %include 'cc_helpers_dcls.incl.pl1'; %list;
%nolist;  %include 'cc_misc_dcls.incl.pl1';    %list;
%nolist;  %include 'cc_descriptor_strux.incl.pl1';  %list;
%nolist;  %include 'object_disk.incl.pl1';     %list;

%nolist;  %include 'capacity.incl.pl1';        %list;
%nolist;  %include 'system_io_constants';      %list;

declare BUGON_high       bit(1) static external initial(false);
declare yes_mod          bin(31) static external initial(0);
declare no_mod           bin(31) static external initial(0);

%page;

declare  decode_string        entry (char(*) var);
declare  encode_string        entry (char(*) var, char(*) var);
declare  encode_byte          entry (bin(15)) returns (char(2) var);

%replace MAX_PROCESSES        by 32;
declare  object_id_array      fixed bin(15) external static;
declare  1 next(-1:MAX_PROCESSES-1) based(addr (object_id_array)),
           2 object_id             bin(31),
           2 text_id               bin(31);


declare  random_seed                    binary (31)   external;
declare  today_start_time               binary (31)   external;

declare  process_number                 char   (10)   varying external;

%replace server_event                   by    1;
%replace subsys_event                   by    2;
%replace habitat_event                  by    3;
%replace db_event                       by    4;
%replace tact_event                     by    5;
%replace obn_event                      by    6;
%replace max_events                     by    6;

declare  MainQ                          pointer external initial(null()) ;
declare  SubSysQ                        pointer external initial(null()) ;
declare  habitatQ                       pointer external initial(null()) ;
declare  habitat_dbQ                    pointer external initial(null()) ;

declare  ec (64)                        binary (31)   static   external;
declare  ei (64)                        binary (31)   static   external;

declare shared_file_path                char(256) var external;
declare shared_file_port                bin(15) external;

declare content                         char(1150) var external;
declare databytes                       char(1150) var external;
declare ContList                        char(1150) var external;

declare prefix                          char(6) var external;
declare response                        char(2048) var external;
declare encoded                         char(2048) var external;

declare leave_region                    char(4) var external;

declare partial_input                   pointer external initial(null());
declare Updates                         pointer external initial(null());

declare Daymessage                      char(100) var external;
declare Mailmessage                     char(33) var external init(
                                        '* You have MAIL in your pocket. *');

%page;
regionproc:  procedure  options (main);
   declare  event_index                 binary (15);
   declare  code                        binary (15);
   declare  index                       binary (15);
   declare  task                        binary (15);
   declare  event                       binary (31);
   declare  count                       binary (31);
   declare  status                      binary (31);

   call initialize_roomer;
   call calculate_today_start (null());

   do  while (true);
       call s$task_wait_event (Master_ei, wait_forever, task, event,
                               event_index, count, status, code);
       if (code ^= 0)  then do;
           call debug_msg (code, 'task_wait_event ' || 'task = ' || ltrim(task)
                                 || ' index = ' || ltrim(event_index));
           if (code = e$invalid_eventid   &
               task ^= 0   &   task ^= tact_event)  then do;
               call s$task_setup_wait (Master_ei, task, 0, tact_ei, tact_ec,
                                       wait_forever, index, code);
               if (code ^= 0)  then  call debug_msg (code, 'err task setup wait');
               end;
           end;

         else if (task = server_event)   then  call handle_msg (task);
         else if (task = subsys_event)   then  call handle_msg (task);

         else if (task = db_event)       then  call resend_msg (habitat_dbQ);
         else if (task = habitat_event)  then  call resend_msg (habitatQ);
         else if (task = tact_event)     then  call ProcessTact;

         else if (task = obn_event)   then  call resend_msg (Q_ptrs (event_index));
         end;

end  regionproc;

%page;
initialize_roomer:  procedure;
   declare  i                           binary (15);
   declare  mask                        binary (31);
   declare  pid                         binary (31); 
   declare  buf                         char    (4)   defined  (pid);
   declare  qp                          pointer;
   declare  code                        binary (15);
   declare  tstr                        char    (8);
   declare  queue_id                    bin(31);
   declare  habitat_log                 bit(1) aligned;

   declare  process_num                 binary(15);
   declare  process_num_bytes           char (2) defined (process_num);

   call s$parse_command ('regionproc', code,
                         'ProcessNumber:string,required', process_number,
                         'switch(-subsys_log),=1', habitat_log,
                          'end');
   if (code ^= 0)  then  stop;

   process_num = binary (process_number, 15);

   if (habitat_log) then call set_debug_queue ('habitat_debug');

   call initialize_queues_and_tasks ('region.'  ||  process_number, MainQ,
                                     max_events, obn_event, tact_event);

   call make_server_queue ('region_big.'  ||  process_number, subsys_event,
                           SubSysQ, queue_id);

   do  RoomNumber = 1 to REGIONS_PER_PROCESS;
       allocate  RoomDBank  set (RoomPtr);
       RoomPtrs (RoomNumber)       = RoomPtr;
       RoomDBank.initialized       = false;
       RoomDBank.total_ghosts      = 0;
       RoomDBank.avatars_coming    = 0;
       RoomDBank.waiting_list      = null();
       RoomDBank.GhostList         = null();
       RoomDBank.Block_addr        = null();
       current_region.object_count = 0;
       oracle.object  = 0;
       oracle.person  = 0;
       oracle.control = null();
       do  i = 1 to USERS_PER_REGION;
           UserList (i) = null ();
           end;
       do  i = 0 to OBJECTS_PER_REGION;
           ObjList (i) = null ();
           end;
       allocate RoomCMon set (CapMonPtr);
       CapMonPtrs(RoomNumber) = CapMonPtr;
       call make_sub_server_queue ('region.' || process_number, 
                                    server_event, RoomNumber, qp, RoomQid);
       call make_sub_server_queue ('region_big.' || process_number, 
                                    subsys_event, RoomNumber, qp, RoomBQid);
       end;

   /* Preallocate for last slot since its most likely to be used. */
   allocate Memory_Block set (RoomDBank.Block_addr);
   Block_addr->Memory_Block.free = 'ffffffffffffffff'b4;

   call make_sender_queue ('habitat_big',      habitat_event, habitatQ);
   call make_sender_queue ('habitat_db',       db_event,      habitat_dbQ);

   call process_config_file;
   call initialize_shared_memory;
   call initialize_structs;

   do i = 1 to MAX_CLASS_NUMBER;
      classes(i).resources = null();
      end;
   call initialize_resource_pointers;

   Daemons.EntryRoutine(1) = entry_turn_nude;
   Daemons.EntryRoutine(2) = entry_return_from_nude;

   leave_region = encode_byte(0) || encode_byte(2);

   call s$int_date_time (random_seed);

   call send_msg_var (habitatQ, MSG$PROCESS_GOING, (process_num_bytes));

end  initialize_roomer;
%page;
process_config_file: procedure;
declare port   bin(15);
declare bc     bin(15);
declare code   bin(15);
declare buffer char(256);
declare 1 buff defined (buffer),
          2 field   bin(15),
          2 data    char(254);

declare dp pointer;
declare charvar     char(252) var  based (dp);
declare bin31       bin(31)        based (dp);

   Daymessage = 'Welcome to Club Caribe! (+)';
   call s$int_date_time (Holes_open);

   call open_file ('CC_config', port, SEQUENTIAL_FILE, 256, INPUT_TYPE,
                   IMPLICIT_LOCKING, SEQUENTIAL_MODE, '', code);
   if (code ^= 0) then do;
       call debug_msg (code, 'Open config file');
       return;
       end;

   dp = addr(buff.data);

   do while (code = 0);
      call s$seq_read (port, 256, bc, buffer, code);
      if (code = 0) then do;
          if (buff.field = 1) then 
               Daymessage = charvar;
          else if (buff.field = 2) then
               Holes_open = bin31;
          else call trace_msg ('Unknown config field ' || ltrim(buff.field));
          end;
      end;

   call s$close (port,code);
   if (code ^= 0) then call debug_msg (code,'close config file');
   call s$detach_port (port,code);

end process_config_file;
%page;
initialize_shared_memory: procedure;

dcl  s$attach_port            entry (char(32) var, char(256) var, bin (15),
                                     bin (15), bin (15));
dcl  s$connect_vm_region      entry (bin (15), bin (15), bin (15), bin (31),
                                     bin (15), bin (15), bin (15));
dcl  s$open                   entry (bin (15), bin (15), bin (15), bin (15),
                                     bin (15), bin (15), char(32) var, bin (15));

%replace DONT_HOLD                 by 0;

%replace NO_COPY_ON_REF            by 0;
%replace ONE_PAGE                  by 1;
%replace STARTING_WITH_1ST         by 1;
%replace VM_ACCESS_MODE            by 7;
%replace VM_READ_AND_WRITE_ACCESS  by 2;

declare code bin(15);

   call s$expand_path ('CC_object_ids', '', shared_file_path,code);
   if (code ^= 0) then call die_msg (code, 'expanding VM path');
   call s$attach_port ('', shared_file_path, DONT_HOLD, shared_file_port, code);
   if (code ^= 0) then call die_msg (code, 'attaching VM port');

   call s$open (shared_file_port, FIXED_FILE, 4096, UPDATE_TYPE,
               IMPLICIT_LOCKING, VM_ACCESS_MODE, '', code);
   if (code ^= 0) then call die_msg (code, 'open VM file');

   call s$connect_vm_region (shared_file_port, object_id_array,
               ONE_PAGE, STARTING_WITH_1ST,
               VM_READ_AND_WRITE_ACCESS, NO_COPY_ON_REF, code);
   if (code ^= 0) then call die_msg (code, 'connecting to VM region');

end initialize_shared_memory;
%page;
initialize_structs: procedure;
declare i bin(15);
declare instance_head_size bin(15);
declare props_size bin(15);

  do i = 0 to 255;
     Class_Table(i).known  = false;
     end;

  call initialize_class_amulet;
  call initialize_class_aquarium;
  call initialize_class_atm;
  call initialize_class_avatar;
  call initialize_class_bag;
  call initialize_class_ball;
  call initialize_class_book;
  call initialize_class_bottle;
  call initialize_class_box;
  call initialize_class_bridge;
  call initialize_class_building;
  call initialize_class_bush;
  call initialize_class_chair;
  call initialize_class_chest;
  call initialize_class_club;
  call initialize_class_coke_machine;
  call initialize_class_compass;
  call initialize_class_couch;
  call initialize_class_crystal_ball;
  call initialize_class_die;
  call initialize_class_display_case;
  call initialize_class_door;
  call initialize_class_drugs;
  call initialize_class_fake_gun;
  call initialize_class_fence;
  call initialize_class_flag;
  call initialize_class_flashlight;
  call initialize_class_flat;
  call initialize_class_floor_lamp;
  call initialize_class_fortune_machine;
  call initialize_class_fountain;
  call initialize_class_game_piece;
  call initialize_class_garbage_can;
  call initialize_class_gemstone;
  call initialize_class_ghost;
  call initialize_class_glue;
  call initialize_class_ground;
  call initialize_class_gun;
  call initialize_class_hand_of_god;
  call initialize_class_head;
  call initialize_class_hole;
  call initialize_class_hot_tub;
  call initialize_class_house_cat;
  call initialize_class_key;
  call initialize_class_knick_knack;
  call initialize_class_knife;
  call initialize_class_magic_lamp;
  call initialize_class_magic_staff;
  call initialize_class_magic_wand;
  call initialize_class_movie_camera;
  call initialize_class_paper;
  call initialize_class_pawn_machine;
  call initialize_class_picture;
  call initialize_class_plant;
  call initialize_class_plaque;
  call initialize_class_pond;
  call initialize_class_region;
  call initialize_class_rock;
  call initialize_class_safe;
  call initialize_class_sex_changer;
  call initialize_class_short_sign;
  call initialize_class_shovel;
  call initialize_class_sign;
  call initialize_class_sky;
  call initialize_class_spray_can;
  call initialize_class_street;
  call initialize_class_streetlamp;
  call initialize_class_stun_gun;
  call initialize_class_super_trapezoid;
  call initialize_class_switch;
  call initialize_class_table;
  call initialize_class_teleport;
  call initialize_class_tokens;
  call initialize_class_trapezoid;
  call initialize_class_tree;
  call initialize_class_vendo_front;
  call initialize_class_vendo_inside;
  call initialize_class_wall;
  call initialize_class_window;
  call initialize_class_windup_toy;

  instance_head_size = size(object) - 40;
  do i = 0 to 255;
     if (Class_Table(i).known) then do;
        if (Class_Table(i).alloc_size < instance_head_size) then do;
           call trace_msg ('Class ' || ltrim(i) || ' has bad alloc_size');
           Class_Table(i).alloc_size = instance_head_size;
           end;
        props_size = Class_Table(i).alloc_size - instance_head_size;
        props_size = divide(props_size,8,15);
        if (Class_Table(i).capacity ^= 0)
           then props_size = props_size - 4;
        Class_Table(i).class_bytes = props_size;
        end;
     else Class_Table(i).actions = null();
     end;
  Class_Table(CLASS_AVATAR).class_bytes = 
           Class_Table(CLASS_AVATAR).class_bytes + 10; /* Allow for name */

  call initialize_magic;
  call initialize_drugs;

  call initialize_object_disk_patches;

end initialize_structs;
%page;
initialize_resource_pointers: procedure;
        classes(0).resources = addr(class_0_resource_array);
        classes(1).resources = addr(class_1_resource_array);
        classes(2).resources = addr(class_2_resource_array);
        classes(3).resources = addr(class_3_resource_array);
        classes(4).resources = addr(class_4_resource_array);
        classes(5).resources = addr(class_5_resource_array);
        classes(6).resources = addr(class_6_resource_array);
        classes(7).resources = addr(class_7_resource_array);
        classes(10).resources = addr(class_10_resource_array);
        classes(12).resources = addr(class_12_resource_array);
        classes(13).resources = addr(class_13_resource_array);
        classes(16).resources = addr(class_16_resource_array);
        classes(17).resources = addr(class_17_resource_array);
        classes(18).resources = addr(class_18_resource_array);
        classes(20).resources = addr(class_20_resource_array);
        classes(21).resources = addr(class_21_resource_array);
        classes(22).resources = addr(class_22_resource_array);
        classes(23).resources = addr(class_23_resource_array);
        classes(24).resources = addr(class_24_resource_array);
        classes(25).resources = addr(class_25_resource_array);
        classes(26).resources = addr(class_26_resource_array);
        classes(27).resources = addr(class_27_resource_array);
        classes(28).resources = addr(class_28_resource_array);
        classes(29).resources = addr(class_29_resource_array);
        classes(30).resources = addr(class_30_resource_array);
        classes(31).resources = addr(class_31_resource_array);
        classes(32).resources = addr(class_32_resource_array);
        classes(33).resources = addr(class_33_resource_array);
        classes(35).resources = addr(class_35_resource_array);
        classes(36).resources = addr(class_36_resource_array);
        classes(37).resources = addr(class_37_resource_array);
        classes(38).resources = addr(class_38_resource_array);
        classes(42).resources = addr(class_42_resource_array);
        classes(43).resources = addr(class_43_resource_array);
        classes(44).resources = addr(class_44_resource_array);
        classes(45).resources = addr(class_45_resource_array);
        classes(46).resources = addr(class_46_resource_array);
        classes(47).resources = addr(class_47_resource_array);
        classes(48).resources = addr(class_48_resource_array);
        classes(49).resources = addr(class_49_resource_array);
        classes(52).resources = addr(class_52_resource_array);
        classes(54).resources = addr(class_54_resource_array);
        classes(55).resources = addr(class_55_resource_array);
        classes(56).resources = addr(class_56_resource_array);
        classes(57).resources = addr(class_57_resource_array);
        classes(58).resources = addr(class_58_resource_array);
        classes(60).resources = addr(class_60_resource_array);
        classes(61).resources = addr(class_61_resource_array);
        classes(64).resources = addr(class_64_resource_array);
        classes(69).resources = addr(class_69_resource_array);
        classes(70).resources = addr(class_70_resource_array);
        classes(74).resources = addr(class_74_resource_array);
        classes(75).resources = addr(class_75_resource_array);
        classes(76).resources = addr(class_76_resource_array);
        classes(80).resources = addr(class_80_resource_array);
        classes(82).resources = addr(class_82_resource_array);
        classes(84).resources = addr(class_84_resource_array);
        classes(85).resources = addr(class_85_resource_array);
        classes(86).resources = addr(class_86_resource_array);
        classes(87).resources = addr(class_87_resource_array);
        classes(88).resources = addr(class_88_resource_array);
        classes(89).resources = addr(class_89_resource_array);
        classes(90).resources = addr(class_90_resource_array);
        classes(91).resources = addr(class_91_resource_array);
        classes(92).resources = addr(class_92_resource_array);
        classes(93).resources = addr(class_93_resource_array);
        classes(94).resources = addr(class_94_resource_array);
        classes(95).resources = addr(class_95_resource_array);
        classes(96).resources = addr(class_96_resource_array);
        classes(97).resources = addr(class_97_resource_array);
        classes(98).resources = addr(class_98_resource_array);
        classes(99).resources = addr(class_99_resource_array);
        classes(127).resources = addr(class_127_resource_array);
        classes(129).resources = addr(class_129_resource_array);
        classes(130).resources = addr(class_130_resource_array);
        classes(131).resources = addr(class_131_resource_array);
        classes(132).resources = addr(class_132_resource_array);
        classes(133).resources = addr(class_133_resource_array);
        classes(134).resources = addr(class_134_resource_array);
        classes(135).resources = addr(class_135_resource_array);
        classes(136).resources = addr(class_136_resource_array);
        classes(137).resources = addr(class_137_resource_array);
        classes(138).resources = addr(class_138_resource_array);
        classes(139).resources = addr(class_139_resource_array);
        classes(140).resources = addr(class_140_resource_array);
        classes(141).resources = addr(class_141_resource_array);
        classes(143).resources = addr(class_143_resource_array);
        classes(144).resources = addr(class_144_resource_array);
        classes(147).resources = addr(class_147_resource_array);
        classes(150).resources = addr(class_150_resource_array);
        classes(152).resources = addr(class_152_resource_array);
        classes(153).resources = addr(class_153_resource_array);
        classes(154).resources = addr(class_154_resource_array);
        classes(155).resources = addr(class_155_resource_array);
        classes(156).resources = addr(class_156_resource_array);
        classes(157).resources = addr(class_157_resource_array);
        classes(158).resources = addr(class_158_resource_array);
        classes(255).resources = addr(class_255_resource_array);
end initialize_resource_pointers;

%page;
handle_msg:  procedure (task);
declare task             binary(15);
declare mtype            binary(31);
declare len              binary(31);
declare uid              binary(31);
declare qid              binary(31);
declare sub_addr         binary(15);
declare code             binary(15);
declare buffer           character(1024);
declare obuf             character(1024) varying;


   do while (true);
     if (task = server_event)
        then call get_sub_msg (MainQ,   mtype, buffer, 
                  length(buffer), len, uid, qid, sub_addr);
        else call get_sub_msg (SubSysQ, mtype, buffer, 
                  length(buffer), len, uid, qid, sub_addr);
     if (mtype = -1) then return;

     obuf = substr(buffer,1,len);

     RoomNumber = sub_addr;
     RoomPtr    = RoomPtrs(RoomNumber); 
     CapMonPtr  = CapMonPtrs(RoomNumber); 

     if (mtype = MSG$TERMINAL_MESSAGE)
         then call process_input (obuf, uid, qid); 

     else if (mtype = MSG$START_ROOM) 
         then call process_start_room (addr(buffer));

     else if (mtype = MSG$LOOKUP_RESULTS) 
         then call process_lookup_results (addr(buffer),uid,qid);

     else if (mtype = MSG$ADD_OBJECTS) then do;
         call process_users_objects (addr(buffer));
         call process_add_user (uid,qid);
         end;

     else if (mtype = MSG$USER_ENTER_ROOM) 
         then call process_enter_room (obuf,uid,qid);

     else if (mtype = MSG$CHANGE_ROOM_RESULT) 
         then call process_change_result (addr(buffer),uid,qid);

     else if (mtype = MSG$CHANGE_ROOM_FAILED)
         then call process_changeroom_fail (uid,qid);

     else if (mtype = MSG$FOUND_ID) 
         then call process_messager_name_result (addr(buffer),uid);

     else if (mtype = MSG$HABITAT_OLM) 
         then /* call send_messager_msg (addr(buffer)) */ ;

     else if (mtype = MSG$USER_STATS) then do;
         call format_player_list (addr(buffer));
         call send_latest_players (uid,qid);
         end;

     else if (mtype = MSG$USER_UNPLUGGED)
         then call process_unplugged (uid,qid);

     else if (mtype = MSG$MAIL_ARRIVED)
         then call process_new_mail (addr(buffer),uid);

     else if (mtype = MSG$STATFLUSH) then do;
         call send_stats;
         end;

     else if (mtype = MSG$DEBUG_MSG) then do;
         call debug_on (buffer,len);
         end;

     else call trace_msg (' Unknown msg type = '  ||  ltrim (mtype)  ||
                                       ' uid = '  ||  ltrim (uid)    ||
                                       ' qid = '  ||  ascii_qid (qid));
   end;

end handle_msg;
%page;
process_start_room: procedure (buff);
declare buff             pointer;
declare 1 buff_olay      based (buff),
          2 region_id    bin(31),
          2 starter      bin(31),
          2 pub_pri      char(1);
declare obuf_str char(10);
declare 1 obuf defined (obuf_str),          /*msg format - db lookup request*/
          2 db_function       bin(15),
          2 region_number     bin(31),
          2 transaction       bin(31),
          2 who               bin(31);
declare short_id(4) char(1) defined(buff_olay.region_id);


    RoomDBank.initialized = false;
    if (RoomDBank.Block_addr = null())
       then allocate Memory_Block set (RoomDBank.Block_addr);
    Block_addr->Memory_Block.free = 'ffffffffffffffff'b4;

    obuf.db_function   = CC$dbf_desc_region;
    obuf.region_number = region_id;
    obuf.who           = starter;
    obuf.transaction   = 0;
    call send_message (habitat_dbQ, MSG$DB_LOOKUP, obuf_str, 14, 0, RoomBQid);

    Region               = region_id;   /* @ */
    call cleanup_region_lists;
    call initialize_capacity_monitor;

    oracle.object        = 0;
    oracle.person        = 0;
    oracle.control       = null();
    RoomDBank.last_noid  = 0;
    RoomDBank.owner_here = false;
    if (BUGON) then
       call trace_msg ('Starting region ' || ltrim(region_id) || '/' ||
                       ltrim(RoomNumber));

end process_start_room;
%page;
cleanup_region_lists: procedure;
declare i                binary(15);
declare le               pointer;
declare ptr              pointer;

     do i = 1 to USERS_PER_REGION;
          if (UserList(i) ^= null()) then do;
             if (UserList(i)->player.online)
                then call trace_msg ('Recycle region w/user online: '  ||
                               ltrim(UserList(i)->player.U_Id) || '/' ||
                               ltrim(Region));
             free UserList(i) -> player;
             UserList(i) = null();
          end;
    end;

    do i = 0 to OBJECTS_PER_REGION;
       if (ObjList(i) ^= null()) then do;
          if (Class_Table(ObjList(i)->object.class).capacity ^= 0)
             then call my_free (ObjList(i)->object.param1);
          call my_free (ObjList(i));
          ObjList(i) = null();
          end;
    end;

    do while (RoomDBank.GhostList ^= null());
       call get_from_head_of_list (RoomDBank.GhostList, ptr);
       free ptr -> player;
       end;

    do while (RoomDBank.waiting_list ^= null());
       call get_from_head_of_list (RoomDBank.waiting_list, ptr);
       if (ptr->enter_info.type = 1)
          then free ptr -> enter_info;
          else free ptr -> mug_shot;
       end;

    if (BUGON_high) then call trace_msg ('cleanup_region_lists: ' ||
                                         ltrim(Region));
    RoomDBank.total_ghosts   = 0;
    RoomDBank.avatars_coming = 0;
    current_region.lighting  = 0;

end cleanup_region_lists;
%page;
my_free: procedure (where);
declare where pointer;

declare ptr       pointer;
declare usage(64) bit(1) based(ptr);
declare i         bin(15);
declare found     bit(1) aligned;

   ptr = addrel(RoomDBank.Block_addr, MB$chunk_size * 64);
   if (where > RoomDBank.Block_addr  &  where < ptr) then do;
      found = false;
      ptr = addrel(RoomDBank.Block_addr,8);
      do i = 1 to 64 while (^found);
         if (where = addrel(ptr,(i-1)*MB$chunk_size)) then do;
            ptr = RoomDBank.Block_addr;
            usage(i) = true;
            found = true;
            end;
         end;
      if (^found) then call trace_msg ('Tried to free ' || show_ptr(where) ||
                                       ', block starts at ' || 
                                       show_ptr(RoomDBank.Block_addr));
      end;
   else do;
      call s$free(where);
      end;

end my_free;
%page;
initialize_capacity_monitor: procedure;
declare i bin(15);

    class_ref_count(0) = 0;
    do i = 1 to MAX_CLASS_NUMBER;
       class_ref_count(i) = 0;
       resource_ref_count(i)= 0;
       end;
    do i = (MAX_CLASS_NUMBER + 1) to NUMBER_OF_RESOURCES;
       resource_ref_count(i)= 0;
       end;

    current_region.space_usage  = 0;
    current_region.object_count = 0;

end initialize_capacity_monitor;
%page;
process_lookup_results: procedure (buff,uid,qid);
declare buff             pointer;
declare 1 buff_olay      based (buff),
          2 function     bin(15),
          2 container    bin(31),
          2 count        bin(15);

declare uid              binary(31);
declare qid              binary(31);
declare i                binary(15);


     goto lookup(function);

lookup(CC$dbf_desc_region):                        /*   1   */
     call add_objects_to_region (buff);
     return;

lookup(CC$dbf_contents):                           /*   2   */
     call add_container_contents (buff);
     return;

lookup(CC$dbf_read_text):                          /*   3   */
     call send_text (buff,uid);
     return;

lookup(CC$dbf_locate_teleport):                    /*   4   */
     call process_teleport (buff,uid);
     return;

lookup(CC$dbf_mail_check):                         /*   7   */
     call handle_mail_check (buff);
     return;

lookup(CC$dbf_avatar_desc):                        /*   8  */
     call complete_switch_from_ghost (buff,uid);
     return;

lookup(CC$dbf_oracle_msg):                         /*   9  */
     call process_oracle_msg (buff);
     return;

lookup(CC$dbf_read_title):                         /*  10  */
     call process_book_title (buff,uid);
     return;

lookup(CC$dbf_init_welcome):                       /*  11  */
     return;

lookup(CC$dbf_name_region):                        /*  12  */
     call process_region_name (buff,uid);
     return;

lookup(CC$dbf_locate_player):                      /*  13  */
     /* call process_player_location (buff,uid);   */
     return;

/*  end of process_lookup_results code */

%page;
add_objects_to_region: procedure(buff);
declare buff             pointer;
declare 1 buff_olay      based (buff),
          2 function     bin(15),
          2 container    bin(31),
          2 count        bin(15),
          2 transaction  bin(31);

declare op pointer;

declare (i,j,k)          bin(15);
declare umember          bin(15);

     op = addrel(buff,12);
     do i = 1 to count;

        if (op->obj_desc.class = byte(CLASS_REGION)) then do;
           if (i ^= count) then call trace_msg ('Region ' || 
                            ltrim(op->obj_desc.id) || ' not last in init!!!');
           call initialize_region;
           call clear_waiting_list;
           return;
           end;

        call initialize_object;
        op = addrel(op,op->obj_desc.prop_len+obj_fixed);
    end;

%page;
initialize_region: procedure;
declare allocation  bin(31);

declare  1 region_props defined (op->obj_desc.props),
           2 links(4)    bin(31),
           2 exits(4)    bin(15),
           2 area        char(20),
           2 to_town     char(1),
           2 to_port     char(1);
declare (usernoid,i) bin(15);

    RoomDBank.initialized   = true;
    RoomDBank.noid_wrap     = false;

    if (op->obj_desc.container = -2) then do;          /* No such region. */
       RoomDBank.refuse_entry = true;
       return;
       end;
    else RoomDBank.refuse_entry = false;

    allocation = Class_Table(0).alloc_size;
    if (allocation < size(object)-40)
       then allocation = size(object) - 40;

    call my_allocate (allocation,ObjList(0));
    ObjList(0)->object.noid       = 0;
    ObjList(0)->object.obj_id     = op->obj_desc.id;
    ObjList(0)->object.class      = CLASS_REGION;
    ObjList(0)->object.position   = 0;
    ObjList(0)->object.x          = 0;
    ObjList(0)->object.y          = 0;
    ObjList(0)->object.style      = 0;
    ObjList(0)->object.avatarslot = 0;
    ObjList(0)->object.container  = 0;
    ObjList(0)->object.gr_state   = 0;
    ObjList(0)->object.gr_width   = 0;
    ObjList(0)->object.gen_flags  = copy(false,32);

    call note_object_creation (0,0);
    if (^ mem_checks_ok (0))
       then call trace_msg ('Dreaded MEM FAULT for region ' || ltrim(Region));

    Region_name = area;
    current_region.lighting     = current_region.lighting + op->obj_desc.x_pos;
    current_region.depth        = rank(op->obj_desc.y_pos);
    current_region.owner        = op->obj_desc.container;
    current_region.orientation  = rank(op->obj_desc.orientation);
    current_region.entry_proc   = rank(op->obj_desc.graph_state);
    current_region.exit_proc    = rank(op->obj_desc.graph_width);
    current_region.neighbor(1)  = links(3);
    current_region.neighbor(2)  = links(1);
    current_region.neighbor(3)  = links(4);
    current_region.neighbor(4)  = links(2);
    current_region.exit_type(1) = exits(3);
    current_region.exit_type(2) = exits(1);
    current_region.exit_type(3) = exits(4);
    current_region.exit_type(4) = exits(2);
    current_region.town_dir     = to_town;
    current_region.port_dir     = to_port;

    current_region.max_avatars  = rank(op->obj_desc.position);
    if (current_region.max_avatars > USERS_PER_REGION) then do;
       current_region.max_avatars = USERS_PER_REGION;
       call trace_msg ('WARNING: Region ' || ltrim(Region) || 
                       ' has illegal avatar limit.');
       end;

    current_region.restriction(1) = op->obj_desc.gen_flags(1);
    current_region.restriction(2) = op->obj_desc.gen_flags(2);
    current_region.restriction(3) = op->obj_desc.gen_flags(3);
    current_region.restriction(4) = op->obj_desc.gen_flags(4);

    do i = 1 to 28;
       current_region.nitty_bits(i) = op->obj_desc.gen_flags(i+4);
       end;

    if (current_region.owner = -1)
       then RoomDBank.private = false;
       else RoomDBank.private = true;

end initialize_region;
%page;
clear_waiting_list: procedure;
declare le pointer;
declare ei pointer;

    le = RoomDBank.waiting_list;
    do while (le ^= null());
       ei = le->le_content;
       le = le->le_next;
       if (ei->enter_info.type = 1) then do;
          call retry_user_enter (ei);
          call delete_from_list (RoomDBank.waiting_list, ei); /* FIX THIS */
          end;
       end;

    if (BUGON_high) then call trace_msg ('Region ' || ltrim(Region) ||
                         ' initialized, clearing waiting_list');
end clear_waiting_list;
%page;
initialize_object: procedure;

    call next_available_noid(j);
    if (j < 0) then return;
    call create_object_entry (op,j,true,true);

    if (op->obj_desc.class = byte(CLASS_FLASHLIGHT) |
        op->obj_desc.class = byte(CLASS_FLOOR_LAMP))
       then call increment_lighting (ObjList(j));

end initialize_object;
%page;
increment_lighting: procedure (ptr);
declare ptr  pointer;
declare cptr pointer;

declare 1 light based (ptr)
%include 'struct_flashlight';

   if (light.on = 0) then return;
   cptr = ObjList(light.container);
   if (cptr ^= null())
      then if (container_is_opaque (cptr->object.class,light.position))
          then return;

   current_region.lighting = current_region.lighting + 1;

end increment_lighting;
end add_objects_to_region;
end process_lookup_results;
%page;
set_mail_object_values: procedure (i);
declare i           bin(15);
declare my_noid     bin(15);
declare paper_noid  bin(15);
declare properstate bin(15);

   if (UserList(i)->player.has_mail)
      then properstate = 2;
      else properstate = 0;

   my_noid = UserList(i)->player.object_slot;
   paper_noid = ObjList(my_noid)->object.param1->element(4);
   if (paper_noid = 0  |  ObjList(paper_noid) = null()) then do;
      call trace_msg ('No mail object for user ' || 
                      ltrim(UserList(i)->player.U_Id));
      return;
      end;
   if (ObjList(paper_noid)->object.class ^= CLASS_PAPER) then do;
      call trace_msg ('No mail object for user ' || 
                      ltrim(UserList(i)->player.U_Id));
      return;
      end;

   ObjList(paper_noid)->object.gr_state = properstate;
   return;

end set_mail_object_values;
%page;
make_a_ghost: procedure;

   if (ObjList(GHOST) ^= null()) then return;

   call my_allocate (size(object),ObjList(GHOST));
   ObjList(GHOST)->object.noid        = 255;
   ObjList(GHOST)->object.obj_id      = 0;
   ObjList(GHOST)->object.class       = CLASS_GHOST;
   ObjList(GHOST)->object.position    = 0;
   ObjList(GHOST)->object.orientation = 0;
   ObjList(GHOST)->object.x           = 4;
   ObjList(GHOST)->object.y           = 240;
   ObjList(GHOST)->object.style       = 0;
   ObjList(GHOST)->object.avatarslot  = 0;
   ObjList(GHOST)->object.container   = 0;
   ObjList(GHOST)->object.gr_state    = 0;
   ObjList(GHOST)->object.gr_width    = 0;
   ObjList(GHOST)->object.gen_flags   = copy(false,32);

end make_a_ghost;
%page;
create_object_entry: procedure (ptr,j,increment,clear_mod);
declare ptr    pointer;
declare j      bin(15);
declare increment bit(1);
declare clear_mod bit(1);

declare propsptr              pointer;
declare object_props          char(80) based(propsptr);
declare max_contents          bin(15);
declare k                     bin(15);
declare allocation            bin(31);
declare this_class            bin(15);

     this_class = rank(ptr->obj_desc.class);
     allocation = Class_Table(this_class).alloc_size;
     if (allocation < size(object)-40) then do;
         call trace_msg ('Class_Table.alloc_size is < min for class ' ||
                          ltrim(this_class));
         allocation = size(object) - 40;
         end;
     call my_allocate (allocation,ObjList(j));

     ObjList(j)->object.noid       = j;
     ObjList(j)->object.obj_id     = ptr->obj_desc.id;
     ObjList(j)->object.class      = this_class;
     ObjList(j)->object.position   = rank(ptr->obj_desc.position);
     ObjList(j)->object.x          = ptr->obj_desc.x_pos;
     ObjList(j)->object.y          = rank(ptr->obj_desc.y_pos);
     ObjList(j)->object.style      = rank(ptr->obj_desc.style);
     ObjList(j)->object.orientation = rank(ptr->obj_desc.orientation);
     ObjList(j)->object.gr_state   = rank(ptr->obj_desc.graph_state);
     ObjList(j)->object.gr_width   = rank(ptr->obj_desc.graph_width);
     ObjList(j)->object.gen_flags  = ptr->obj_desc.gen_flags;

     if (clear_mod = true)
        then ObjList(j)->object.gen_flags(MODIFIED) = false;

     if (this_class ^= CLASS_AVATAR) then do;
        ObjList(j)->object.avatarslot = 0;
        ObjList(j)->object.container = 
                                 map_object_to_slot(ptr->obj_desc.container,
                                                rank(ptr->obj_desc.contype));
        if (ObjList(j)->object.container ^= 0) 
           then call add_to_containers_list(ObjList(j)->object.container,j,
                                         rank(ptr->obj_desc.position));
        end;
     else do;
        ObjList(j)->object.avatarslot = map_avatar_to_slot(ptr);
        ObjList(j)->object.container = 0;         /* for now... */
        end;

     max_contents = Class_Table(this_class).capacity;
     if (max_contents = 0)
        then propsptr = addr(ObjList(j)->object.param1);
        else do;
           propsptr = addr(ObjList(j)->object.param2);
           call my_allocate ((max_contents * 16), ObjList(j)->object.param1);
           do k = 0 to max_contents-1;
              ObjList(j)->object.param1->element(k) = 0;
              end;
           end;

     if (this_class = CLASS_AVATAR)
        then substr(object_props,1,ptr->obj_desc.prop_len-10) =
             substr(ptr->obj_desc.props,11,ptr->obj_desc.prop_len-10);
        else substr(object_props,1,ptr->obj_desc.prop_len) =
             substr(ptr->obj_desc.props,1,ptr->obj_desc.prop_len);

     if (oracular_object (this_class)  &  oracle.object = 0)
        then call oracular_setup (j);

     if (^increment) then return;

     current_region.object_count = current_region.object_count + 1;
     if (container_is_opaque (container_class(ObjList(j)->object.container),
                              ObjList(j)->object.position))
        then call note_instance_creation (ObjList(j)->object.class,
                                          ObjList(j)->object.style);
        else call note_object_creation (ObjList(j)->object.class,
                                        ObjList(j)->object.style);

end create_object_entry;
%page;
my_allocate: procedure (size,where);
declare size   bin(31);
declare where  pointer;

declare which  bin(15);
declare usage  bit(64) based(where);

   if (size <= MB$threshold) then do;
      where = RoomDBank.Block_addr;
      which = index (usage, '1'b);
      if (which ^= 0) then do;
         substr(usage,which,1) = false;
         which = ((which-1) * MB$chunk_size) + 8;
         where = addrel (where,which);
         return;
         end;
/*    call trace_msg ('No room in Memory Block:  ' || ltrim(Region) || 
                      ', last_noid=' || ltrim(last_noid));                 */
      end;

   call s$allocate (size,where);
   return;

end my_allocate;
%page;
container_class: procedure (cnoid) returns (bin(15));
declare cnoid bin(15);

  if (cnoid = 0) then return (0);

  if (ObjList(cnoid) ^= null())
     then return (ObjList(cnoid)->object.class);
     else do;
        call trace_msg ('ERR: container_class called with invalid noid');
        return (0);
        end;

end container_class;
%page;
container_is_opaque: procedure (class,pos) returns (bit(1) aligned);
declare class  bin(15);
declare pos    bin(15);

  if (class = CLASS_AVATAR) then
     if (pos = HANDS | pos = HEAD)
        then return (false);
        else return (true);

  return (Class_Table(class).opaque_container);

end container_is_opaque;
%page;
oracular_object: procedure (the_class) returns (bit(1) aligned);
declare the_class bin(15);

  if (the_class = CLASS_FOUNTAIN    |
      the_class = CLASS_MAGIC_LAMP  |
/*    the_class = CLASS_BUREAUCRAT  |   */
      the_class = CLASS_CRYSTAL_BALL) then return (true);

  return (false);

end oracular_object;
%page;
oracular_setup: procedure (object_noid);
declare object_noid bin(15);
declare 1 obuf,                             /*msg format - db lookup request*/
          2 db_function       bin(15),
          2 oracles_id        bin(31);
declare obuf_str char(6) defined (obuf);

   oracle.object = object_noid;
   if (ObjList(object_noid)->object.class ^= CLASS_FOUNTAIN) then return;

   obuf.db_function = CC$dbf_oracle_msg;
   obuf.oracles_id  = ObjList(object_noid)->object.obj_id;
   call send_message (habitat_dbQ, MSG$DB_LOOKUP,obuf_str,6,0,RoomBQid);

end oracular_setup;
%page;
process_oracle_msg: procedure(buff);
declare buff             pointer;
declare 1 buff_olay      based (buff),
          2 function     bin(15),
          2 oracle_id    bin(31),
          2 start_time   bin(31),
          2 end_time     bin(31),
          2 interval     bin(15),
          2 msg_text     char(100) var;
declare current_ts       bin(31);
declare ptr              pointer;

   if (buff_olay.oracle_id ^= ObjList(oracle.object)->object.obj_id)
      then return;

   call s$int_date_time (current_ts);
   if (buff_olay.end_time < current_ts) then return;

   if (oracle.control = null())
      then allocate fountain set(oracle.control);
   ptr = oracle.control;
   ptr->fountain.type       = 1;
   ptr->fountain.which_room = RoomNumber;
   ptr->fountain.start_time = buff_olay.start_time;
   ptr->fountain.end_time   = buff_olay.end_time;
   ptr->fountain.interval   = buff_olay.interval;
   ptr->fountain.msg_text   = buff_olay.msg_text;

   if (ptr->fountain.start_time <= current_ts)
      then current_ts = ptr->fountain.interval;
      else current_ts = ptr->fountain.start_time - current_ts;

   call Tact (broadcast_from_fountain,oracle.control,current_ts);

end process_oracle_msg;
%page;
broadcast_from_fountain: procedure (ptr);
declare ptr    pointer;
declare current_ts binary(31);
declare err    bin(15);

   err = 0;
   if (ptr->fountain.type = 1) then do;
      RoomPtr = RoomPtrs(ptr->fountain.which_room);
      CapMonPtr = CapMonPtrs(ptr->fountain.which_room);
      end;
   else err = 1;
   if (err = 0)
      then if (oracle.object = 0 | ObjList(oracle.object) = null())
         then err = 1;
   if (err = 0)
      then if (ObjList(oracle.object)->object.class ^= CLASS_FOUNTAIN)
         then err = 1;

   if (err ^= 0) then do;
      call s$free (ptr);
      oracle.control = null();
      return;
      end;

   call Build_Fan_List (0,false);
   if (fan_cnt = 0) then return;

   prefix = 'U' || byte(ASYNC_MSG);
   response = byte(0) || byte(OBJECTSPEAK_$) ||
              byte(oracle.object) || ptr->fountain.msg_text;
   call encode_string (response, encoded);

   if (length(prefix)+length(encoded) < 120) then do;
      call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,prefix || encoded, 
                      length(prefix)+length(encoded),0,0);
      end;
   else call send_multiple_packets (null(),prefix,encoded,0,true);

   call s$int_date_time (current_ts);
   if (ptr->fountain.end_time <= current_ts) then do;
      call s$free (ptr);
      oracle.control = null();
      return;
      end;

   call Tact (broadcast_from_fountain,ptr,ptr->fountain.interval);

end broadcast_from_fountain;
%page;
cancel_oracle_timer: procedure;

   if (oracle.control = null()) then return;

   if (oracle.control->fountain.type < 1 | oracle.control->fountain.type > 2)
       then do;
       call trace_msg ('cancel_oracle_timer called with unknown type');
       return;
       end;

   if (oracle.control->fountain.type = 1)
      then call ClearTactByValue (broadcast_from_fountain,oracle.control);
   else if (oracle.control->fountain.type = 2)
      then /* call ClearTactByValue (what_chip_calls_it,oracle.control) */;

   call s$free (oracle.control);
   oracle.control = null();

end cancel_oracle_timer;
%page;
add_to_containers_list: procedure (contain,obj,position);

declare contain bin(15);
declare obj     bin(15);
declare position bin(15);
declare bad     bin(15);

    if (contain = 0) then return;

    if (ObjList(contain)->object.param1->element(position) ^= 0) then do;
/*     call trace_msg ('*ERR* Container ' || 
 *                     ltrim(ObjList(contain)->object.obj_id) || '/' ||
 *                     ltrim(contain) || ' has multiple objects in slot ' ||
 *                     ltrim(position));          */
       bad = ObjList(contain)->object.param1->element(position);
       call trace_msg ('DUP CONTENTS, TRIED TO ADD: ' ||
                       ltrim(ObjList(obj)->object.obj_id));
/*     ObjList(bad)->object.container = 0;        */
       ObjList(obj)->object.container = 0;
       ObjList(obj)->object.gen_flags(MODIFIED) = true;
       return;
       end;

    if (position < 0  |
        position > Class_Table(ObjList(contain)->object.class).capacity) then do;
        call trace_msg ('*ERR* Position out of range for container ' ||
                        ltrim(ObjList(contain)->object.obj_id));
        ObjList(obj)->object.container = 0;
        ObjList(obj)->object.gen_flags(MODIFIED) = true;
        return;
        end;

    ObjList(contain)->object.param1->element(position) = obj;

end add_to_containers_list;
%page;
next_available_noid: procedure (new_noid);
declare new_noid     bin(15);
declare highest_noid bin(15);

     highest_noid = OBJECTS_PER_REGION - 1;
     if (RoomDBank.last_noid < highest_noid) then do;
        do new_noid = (RoomDBank.last_noid+1) to highest_noid
        while(ObjList(new_noid) ^= null());
        end;
        if (new_noid <= highest_noid) then do;
           RoomDBank.last_noid = new_noid;
           return;
           end;
        end;

     RoomDBank.noid_wrap = true;
     do new_noid = 1 to (RoomDBank.last_noid-1)
     while(ObjList(new_noid) ^= null());
     end;

     if (new_noid = RoomDBank.last_noid) then do;
        call trace_msg ('DISASTER: ObjList full for region ' || ltrim(Region));
        new_noid = -1;
        return;
        end;

     RoomDBank.last_noid = new_noid;

end next_available_noid;
%page;
add_to_userlist: procedure (Ulistslot,userID,where);
declare Ulistslot   bin(15);
declare userID      bin(31);
declare where       bin(15);
declare found       bit(1) aligned;
declare up          pointer;

    found = false;
    do Ulistslot = 1 to USERS_PER_REGION while(^found);
       if (UserList(Ulistslot) ^= null()) then
          if (UserList(Ulistslot)->player.U_Id = userID)
             then found = true;
       end;

    if (^found) then 
       do Ulistslot = 1 to USERS_PER_REGION while(UserList(Ulistslot) ^= null());
       end;                    /* Ulistslot = 1st empty slot in list */
    else do;
       call trace_msg ('User ' || ltrim(userID) || 
                         ' already in user list, region ' || ltrim(Region) ||
                         ', call ' || ltrim(where));
       signal error;
       end;

    if (Ulistslot > USERS_PER_REGION) then do;
       call trace_msg ('Region overflow!!!!');
       Ulistslot = 0;
       return;
       end;

    allocate player set (UserList(Ulistslot));
    up = UserList(Ulistslot);

    up->player.U_Name        = '';
    up->player.U_version     = 0;
    up->player.U_Id          = userID;
    up->player.U_Q           = null();
    up->player.U_Q_Id        = 0;
    up->player.has_mail      = false; 
    up->player.send_mail     = false; 
    up->player.online        = false; 
    up->player.incoming      = false; 
    up->player.cr_pending    = false; 
    up->player.ck_last_login = false; 
    up->player.new_session   = false; 
    up->player.gagged        = false; 
    up->player.last_cmd      = '';

    up->player.esp.to_uid    = 0; 
    up->player.esp.to_qid    = 0; 
    up->player.esp.que       = null();

    up->player.auto_destination = 0;
    up->player.auto_mode        = 0;

end add_to_userlist;
%page;
map_avatar_to_slot: procedure(p) returns (bin(15));
declare p pointer;
declare i bin(15);

    if (p->obj_desc.class ^= byte(CLASS_AVATAR)) then return(0);
    do i = 1 to USERS_PER_REGION;
       if (UserList(i) ^= null()) then
       if (UserList(i)->U_Id = p->obj_desc.id) then return(i);
    end;

    call trace_msg ('Avatar slot not initialized for ' || 
                    ltrim(p->obj_desc.id));
    return(0);

end map_avatar_to_slot;



map_object_to_slot: procedure(objects_id,object_type) returns (bin(15));
declare objects_id  bin(31);
declare object_type bin(15);
declare i bin(15);

     if (object_type = 0) then return(0);
     do i = 1 to OBJECTS_PER_REGION - 1;
        if (ObjList(i) ^= null()) then
        if (ObjList(i)->object.obj_id = objects_id  &
           ((object_type = 1  &  ObjList(i)->object.class = 1) |
           (object_type > 1  &  ObjList(i)->object.class > 1)))
           then return(i);
     end;

     call trace_msg ('Unable to map ' || ltrim(objects_id) || ', type ' ||
                     ltrim(object_type));
     return(0);

end map_object_to_slot;
%page;
get_container_contents: procedure(noid);
declare noid   bin(15);

declare tp     pointer;
declare uno    bin(15);
declare obuf_str char(10);
declare 1 obuf defined (obuf_str),          /*msg format - db lookup request*/
          2 db_function       bin(15),
          2 container         bin(31),
          2 transaction       bin(31);

   uno = avatar.avatarslot;

   obuf.db_function = CC$dbf_contents;
   obuf.container   = ObjList(noid)->object.obj_id;
   obuf.transaction = UserList(uno)->player.U_Id;

   call set_environment (UserList(uno),0,0);

   call send_message (habitat_dbQ, MSG$DB_LOOKUP, obuf_str, 10, 0, RoomBQid);

end get_container_contents;
%page;
add_container_contents: procedure(buff);
declare buff             pointer;
declare 1 buff_olay      based (buff),
          2 function     bin(15),
          2 container    bin(31),
          2 count        bin(15),
          2 uid          bin(31);

declare op               pointer;
declare cur              pointer;
declare (i,j,k)          bin(15);
declare (umember,req)    bin(15);
declare objs(40)         bin(15);
declare cks_passed       bit(1) aligned;

declare container_flags  bin(15);
declare container_bit(16) bit(1) defined(container_flags);
declare 1 container based %include 'struct_gen_container';
%replace OPEN_FLAG by 16;

     call check_request_info (buff_olay.uid,req$open_container,userptr);
     if (userptr = null()) then return;            /* Requester has departed */

     container_flags = ObjList(current_noid)->container.open_flags;
     if (container_bit(OPEN_FLAG) = false  &  
        ObjList(current_noid)->container.container = 0)
        then cks_passed = contents_ok(0);
        else cks_passed = false;

     if (^cks_passed) then do;
        call send_tih_msg (userptr->player.U_Q,
                   'U' || current_header || encode_byte(current_noid) || 
                   encode_byte(current_request) || encode_byte(BOING_FAILURE));
        return;
        end;

     ContList  = '';
     databytes = '';
     content   = byte(SUCCESS);
     op = addrel(buff,12);

     do i = 1 to count;
        if (BUGON) then call trace_msg ('Adding to container, class: ' || 
                        ltrim(rank(op->obj_desc.class)));
        if (op->obj_desc.class = byte(CLASS_AVATAR))
           then call add_to_userlist (umember,op->obj_desc.id,2);
        call next_available_noid (j);
        if (j < 0) then return;
        call create_object_entry (op,j,false,true);
        if (op->obj_desc.class = byte(CLASS_AVATAR) & umember ^= 0) then do;
           UserList(umember)->player.object_slot = j;
           UserList(umember)->player.U_Name = 
                                       rtrim(substr(op->obj_desc.props,1,10));
           end;
        if (op->obj_desc.container = buff_olay.container)
           then call build_vector_entry (j);
        op = addrel(op,op->obj_desc.prop_len+obj_fixed);
     end;

     current_region.object_count = current_region.object_count + count;
     call generic_SET_OPEN_BITS;

%page;
     /* Respond to the requester:  */

     prefix = 'U' || current_header || encode_byte(current_noid) || 
             encode_byte(current_request);

     response = content || byte(0) || databytes || ContList;
     if (length(response) = 2) then response = byte(SUCCESS);
     if (BUGON) then call trace_msg ('Contents: ' || response);
     call encode_string (response, encoded);

     if (length(prefix)+length(encoded) < 120) then do;
        call send_tih_msg (userptr->player.U_Q, prefix || encoded);
        end;
     else call send_multiple_packets (userptr,prefix,encoded,0,true);

     /* Notify all others:  */

     call Build_Fan_List (userptr->player.U_Q_Id,false);
     if (fan_cnt = 0) then return;

     prefix = 'U' || byte(ASYNC_MSG) ||
               encode_byte(avatar.noid) || encode_byte(19);  
     response = byte(selfptr->object.noid);
     if (length(content) ^= 1  |  length(ContList) ^= 0)
        then response = response || substr(content,2) || byte(0) || databytes
                        || ContList;
     call encode_string (response, encoded);

     if (length(prefix)+length(encoded) < 120) then do;
        call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,prefix || encoded, 
                        length(prefix)+length(encoded),0,0);
        end;
     else call send_multiple_packets (null(),prefix,encoded,
                                      userptr->player.U_Q_Id,true);

     return;

%page;
contents_ok: procedure (dummy) returns (bit(1) aligned);
declare dummy bin(15);
declare contained(40) bin(15);
declare contain_val bin(15);

  contain_val = map_object_to_slot (buff_olay.container,2);
  if (contain_val = 0) then return (false);
  if (ObjList(contain_val) = null()) then return (false);
  contain_val = ObjList(contain_val)->object.class * 256;

  if ((buff_olay.count + current_region.object_count) >= CONCURRENT_OBJECTS) then do;
/*   call trace_msg (ltrim(userptr->player.U_Id) ||
                     ':  container not opened (max objs), region ' ||
                     ltrim(Region));    */
     return (false);
     end;

  do j = 1 to 40;
     objs(j) = 0;
     contained(j) = contain_val;
     end;
  op = addrel(buff,12);
  if (count > 40) then do;
     call trace_msg ('Err: Container with more that 40 objects: ' ||
                     ltrim(buff_olay.container));
     count = 40;
     end;
  do j = 1 to count;
     objs(j) = class_style (rank(op->obj_desc.class),rank(op->obj_desc.style));
     op = addrel(op,op->obj_desc.prop_len+obj_fixed);
     end;

  if (^space_available(objs,contained)) then do;
/*   call trace_msg (ltrim(userptr->player.U_Id) ||
                     ':  container not opened (mem), region ' || 
                     ltrim(Region));    */
     return (false);
     end;

  return (true);

end contents_ok;
end add_container_contents;
%page;
print_elements: procedure (id) returns(char(120) var);
declare id     bin(15);
declare elist  char(120)var;
declare ep     pointer;
declare i      bin(15);

  elist = '';
  ep = ObjList(id)->object.param1;
  do i = 1 to Class_Table(ObjList(id)->object.class).capacity-1;
     elist = elist || ltrim(ep->element(i));
     end;

  return (elist);

end print_elements;
%page;
switch_to_ghost: procedure;
declare uno    bin(15);
declare my_noid bin(15);
declare gptr   pointer;
declare tptr   pointer;
declare str    char(10) var;

%replace SUCCESS_NO_VECTOR by 2;

   uno = avatar.avatarslot;
   my_noid = avatar.noid;
   gptr = UserList(uno);

   if (oracle.person = my_noid) then oracle.person = 0;

/* Now, remove the avatar object...        */
   if (avatar.container ^= 0) then do;
      tptr = ObjList(avatar.container)->object.param1;
      tptr->element(avatar.position) = 0;
      avatar.container = 0;
      end;
   avatar.x = -1;
   avatar.y = 128;
   avatar.gen_flags(MODIFIED) = true;
   call checkpoint_object (NULL_REGION,my_noid);
   call remove_object (my_noid);
   call Build_Fan_List (current_qid,false);
   if (fan_cnt > 0) then do;
      str = 'U' || byte(ASYNC_MSG) || encode_byte(0) ||
            encode_byte(9) || encode_byte(my_noid);
      call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,substr(str,1),
                            length(str),0,0);
      end;
   UserList(uno) = null();

/* ...then add the ghost...                  */
   call add_to_list (GhostList,gptr);
   gptr->player.object_slot = GHOST;
   total_ghosts = total_ghosts + 1;

   if (ObjList(GHOST) ^= null()) then do;
      call send_tih_msg (gptr->player.U_Q,
                  'U' || current_header || encode_byte(current_noid) || 
                  encode_byte(current_request) || byte(SUCCESS_NO_VECTOR) ||
                  byte(255) || copy (byte(0), 4));
      return;
      end;

   call make_a_ghost;

   content   = '';
   databytes = '';
   ContList  = '';
   call build_vector_entry (GHOST);
   call build_contents_list (GHOST,true);
   response = content || byte(0) || databytes || ContList;
   call encode_string (response,encoded);

   call Build_Fan_List (current_qid,false);
   if (fan_cnt > 0) then do;
      prefix    = 'U' || byte(ASYNC_MSG) || encode_byte(0) || encode_byte(8);
      if (BUGON) then call trace_msg ('HEREIS: ' || prefix || encoded);
      if (length(prefix)+length(encoded) < 120) then do;
         call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,prefix || encoded, 
                         length(prefix)+length(encoded),0,0);
         end;
      else call send_multiple_packets (null(),prefix,encoded,current_qid,true);
      end;

   prefix = 'U' || current_header || encode_byte(current_noid) || 
              encode_byte(current_request);
   response = encode_byte(SUCCESS) || encode_byte(GHOST) || encode_byte(0) || 
              encode_byte(0) || encode_byte(0) || encode_byte(0) || encoded;
   if (length(prefix)+length(encoded) < 120) then do;
      call send_tih_msg (gptr->U_Q, prefix || response);
      end;
   else do;
      call Build_Fan_List (current_qid,false);
      call send_multiple_packets (gptr,prefix,encoded,current_qid,true);
      end;
   
end switch_to_ghost;
%page;
switch_from_ghost: procedure;
declare tp     pointer;
declare obuf_str char(10);
declare 1 obuf defined (obuf_str),          /*msg format - db lookup request*/
          2 db_function       bin(15),
          2 transaction       bin(31);

   if (avatar_count() >= current_region.max_avatars) then do;
      call send_tih_msg (userptr->player.U_Q,
               'U' || current_header || encode_byte(current_noid) || 
               encode_byte(current_request) || byte(FAILURE));
      return;
      end;
      

   obuf.db_function = CC$dbf_avatar_desc;
   obuf.transaction = userptr->player.U_Id;

   call set_environment (userptr, 0, 0);

   call send_message (habitat_dbQ, MSG$DB_LOOKUP, obuf_str, 6, 0, RoomBQid);

end switch_from_ghost;
%page;
complete_switch_from_ghost: procedure(buff,uid);
declare buff             pointer;
declare 1 buff_olay      based (buff),
          2 function     bin(15),
          2 container    bin(31),
          2 count        bin(15),
          2 curr_time    bin(31);

declare uid bin(31);
declare op               pointer;
declare cur              pointer;
declare (i,j,k)          bin(15);
declare (umember,req)    bin(15);
declare last_ghost       bin(15);
declare my_noid          bin(15);
declare objs(9)          bin(15);
declare uptr             pointer;

declare money_bytes(4) char(1) defined (avatar.bank_account_balance);

   call check_request_info (uid,req$avatar_switch,uptr);
   if (uptr = null()) then return;               /* Requester has departed */

   if (^room_for_avatar(0)) then do;
      call send_tih_msg (uptr->player.U_Q,
               'U' || current_header || encode_byte(current_noid) || 
               encode_byte(current_request) || byte(FAILURE));
      return;
      end;

   ContList  = '';
   databytes = '';
   content   = '';
   op = addrel(buff,12);

   do i = 1 to count;
      if (BUGON) then call trace_msg ('Adding class: ' || 
                      ltrim(rank(op->obj_desc.class)));
      if (op->obj_desc.class = byte(CLASS_AVATAR))
         then call add_to_userlist (umember,op->obj_desc.id,3);
      call next_available_noid (j);
      if (j < 0) then return;
      call create_object_entry (op,j,false,true);
      if (op->obj_desc.class = byte(CLASS_AVATAR) & umember ^= 0) then do;
         call clear_bit (ObjList(j)->object.gr_state,7);
         UserList(umember)->player.object_slot = j;
         UserList(umember)->player.U_Name = 
                                         rtrim(substr(op->obj_desc.props,1,10));
         ObjList(j)->object.x = 8;
         ObjList(j)->object.y = 128;
         my_noid = j;
         end;
      op = addrel(op,op->obj_desc.prop_len+obj_fixed);
   end;

   current_region.object_count = current_region.object_count + buff_olay.count;

   UserList(umember)->player.U_Q          = uptr->player.U_Q;
   UserList(umember)->player.U_Q_Id       = uptr->player.U_Q_Id;
   UserList(umember)->player.U_version    = uptr->player.U_version;
   UserList(umember)->player.has_mail     = uptr->player.has_mail;
   UserList(umember)->player.send_mail    = uptr->player.send_mail;
   UserList(umember)->player.last_mail_ts = uptr->player.last_mail_ts;
   UserList(umember)->player.gagged       = uptr->player.gagged;
   UserList(umember)->player.online       = true;

   userptr = UserList(umember);
   if (uptr->player.ck_last_login)
      then call check_last_login;
   call set_mail_object_values (umember);
   ObjList(my_noid)->avatar.activity = 129;
   call build_vector_entry (my_noid);
   call build_contents_list (my_noid,true);

   if (ObjList(my_noid)->avatar.gr_state = 1  &  oracle.person = 0)
      then oracle.person = my_noid;

%page;

   call delete_from_list (GhostList,uptr);
   free uptr->player;
   total_ghosts = total_ghosts - 1;
   if (ghost_count(1) = 0) then do;
      last_ghost = 2;
      call my_free (ObjList(GHOST));
      ObjList(GHOST) = null();
      end;
   else last_ghost = 0;

   /* Respond to the requester:  */
   avatarptr = ObjList(UserList(umember)->player.object_slot);
   prefix = 'U' || current_header || encode_byte(current_noid) || 
           encode_byte(current_request);

   response = byte(SUCCESS+last_ghost) || 
              byte(UserList(umember)->player.object_slot) || money_bytes(4) ||
              money_bytes(3) || money_bytes(2) || money_bytes(1) ||
              content || byte(0) || databytes || ContList;
   if (BUGON) then call trace_msg ('Contents: ' || response);
   call encode_string (response, encoded);

   if (length(prefix)+length(encoded) < 120) then do;
      call send_tih_msg (UserList(umember)->player.U_Q, prefix || encoded);
      end;
   else call send_multiple_packets (UserList(umember),prefix,encoded,0,true);

/* call checkpoint_object (NULL_REGION,my_noid); */
   call lights_on (ObjList(my_noid));

   /* Notify all others:  */

   call Build_Fan_List (UserList(umember)->player.U_Q_Id,false);
   if (fan_cnt = 0) then return;

   if (last_ghost = 2) then do;
      response = 'U' || byte(ASYNC_MSG) || encode_byte(0) || encode_byte(9) ||
                 encode_byte(GHOST);
      call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,substr(response,1), 
                      length(response),0,0);
      end;

   prefix = 'U' || byte(ASYNC_MSG) || encode_byte(0) || encode_byte(8);
   response = content || byte(0) || databytes || ContList;
   call encode_string (response, encoded);

   call Build_Fan_List (UserList(umember)->player.U_Q_Id,false);
   if (length(prefix)+length(encoded) < 120) then do;
      call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,prefix || encoded, 
                      length(prefix)+length(encoded),0,0);
      end;
   else call send_multiple_packets (null(),prefix,encoded,
                                    UserList(umember)->player.U_Q_Id,true);

   return;

room_for_avatar: procedure (dummy) returns (bit(1) aligned);
declare dummy bin(15);
declare slot bin(15);
declare positions(9) bin(15);

  do slot = 1 to USERS_PER_REGION while (UserList(slot) ^= null());
     end;
  if (slot > USERS_PER_REGION) then return(false);

  if ((buff_olay.count + current_region.object_count) >= CONCURRENT_OBJECTS) then do;
/*   call trace_msg (ltrim(uptr->player.U_Id) ||
                     ':  ghost not switched (max objs), region ' ||
                     ltrim(Region));         */
     return (false);
     end;

  do j = 1 to 9;  
     objs(j) = 0;
     positions(j) = 0;
     end;
  op = addrel(buff,12);
  do j = 1 to count;
     objs(j) = class_style (rank(op->obj_desc.class),rank(op->obj_desc.style));
     if (op->obj_desc.class = byte(CLASS_AVATAR))
        then positions(j) = 0;
        else positions(j) = 256 + rank(op->obj_desc.position);
     op = addrel(op,op->obj_desc.prop_len+obj_fixed);
     end;

  if (^space_available(objs,positions)) then do;
/*   call trace_msg (ltrim(uptr->player.U_Id) ||
                     ':  ghost not switched (mem), region ' || 
                     ltrim(Region));         */
     return (false);
     end;

  return (true);

end room_for_avatar;
end complete_switch_from_ghost;
%page;
show_text_page: procedure (text_key,text_page,next_page);
declare text_key    bin(31);
declare text_page   bin(15);
declare next_page   bin(15);
declare uno         bin(15);
declare tp          pointer;

declare 1 request,
          2 db_function  bin(15),
          2 object       bin(31),
          2 page         bin(15);
declare request_str char(8) defined(request);

   if (text_key <= 0) then do;
      call send_tih_msg (userptr->player.U_Q,
                 'U' || current_header || encode_byte(current_noid) || 
                 encode_byte(current_request) || copy (byte(10), 4));
      return;
      end;

   uno = avatar.avatarslot;

   request.db_function = CC$dbf_read_text;
   request.object      = text_key;
   request.page        = text_page;

   call set_environment (UserList(uno), next_page, 0);

   call send_message (habitat_dbQ, MSG$DB_LOOKUP, request_str, 8,
                      UserList(uno)->player.U_Id,RoomBQid);

end show_text_page;
%page;
send_text: procedure(buff,uid);
declare buff             pointer;
declare 1 buff_olay      based (buff),
          2 function     bin(15),
          2 key          bin(31),
          2 page         bin(15),
          2 num_pages    bin(15),       /* only valid when page = 1 */
          2 datalen      bin(15),
          2 data         char(640);

declare uid bin(31);
declare bptr pointer;
declare 1 book based(bptr) %include 'struct_book';

   call check_request_info (uid,req$read_text,userptr);
   if (userptr = null()) then return;              /* Requester has departed */

   if (buff_olay.datalen = 0) then do;
      call send_tih_msg (userptr->player.U_Q,
                 'U' || current_header || encode_byte(current_noid) || 
                 encode_byte(current_request) || copy (byte(10), 4));
      return;
      end;

   prefix = 'U' || current_header || encode_byte(current_noid) || 
            encode_byte(current_request);
   response =  substr(request_string,2,1) ||      /* next page number */
               substr(buff_olay.data,1,buff_olay.datalen);
   call encode_string (response, encoded);

   if (length(prefix)+length(encoded) < 120) then do;
      call send_tih_msg (userptr->player.U_Q, prefix || encoded);
      end;
   else call send_multiple_packets (userptr,prefix,encoded,0,true);

   if (buff_olay.page ^= 1) then return;
   bptr = ObjList(current_noid);
   if (bptr ^= null()) then do;
      if (bptr->book.class = CLASS_BOOK | bptr->book.class = CLASS_PLAQUE)
         then bptr->book.last_page = buff_olay.num_pages;
      end;

end send_text;
%page;
get_title_page: procedure (text_key,how_used);
declare text_key    bin(31);
declare how_used    bin(15);
declare uno         bin(15);
declare tp          pointer;

declare 1 request,
          2 db_function  bin(15),
          2 object       bin(31);
declare request_str char(6) defined(request);

   if (text_key <= 0) then do;
      call send_book_title ('', how_used);
      return;
      end;

   uno = avatar.avatarslot;

   request.db_function = CC$dbf_read_title;
   request.object      = text_key;

   call set_environment (UserList(uno), how_used, 0);

   call send_message (habitat_dbQ, MSG$DB_LOOKUP, request_str, 6,
                      UserList(uno)->player.U_Id,RoomBQid);

end get_title_page;
%page;
process_book_title: procedure(buff,uid);
declare buff             pointer;
declare 1 buff_olay      based (buff),
          2 function     bin(15),
          2 key          bin(31),
          2 datalen      bin(15),
          2 data         char(40);

declare uid bin(31);
declare how_used bin(15);

   call check_request_info (uid,req$read_text,userptr);
   if (userptr = null()) then return;               /* Requester has departed */

   how_used = rank(substr(request_string,2,1));
   call send_book_title (substr(buff_olay.data,1,buff_olay.datalen),how_used);

end process_book_title;
%page;
get_region_name: procedure (which);
declare which       bin(31);
declare uno         bin(15);
declare tp          pointer;

declare 1 request,
          2 db_function  bin(15),
          2 region_id    bin(31);
declare request_str char(8) defined(request);

   uno = avatar.avatarslot;

   request.db_function = CC$dbf_name_region;
   request.region_id   = which;

   call set_environment (UserList(uno), 0, 0);

   call send_message (habitat_dbQ, MSG$DB_LOOKUP, request_str, 6,
                      UserList(uno)->player.U_Id,RoomBQid);

end get_region_name;
%page;
process_region_name: procedure(buff,uid);
declare buff             pointer;
declare 1 buff_olay      based (buff),
          2 function     bin(15),
          2 region_id    bin(31),
          2 region_name  char(20);

declare uid bin(31);

   call check_request_info (uid,req$name_region,userptr);
   if (userptr = null()) then return;              /* Requester has departed */

   call trace_msg ('call to get_region_name with no processing code.');

end process_region_name;
%page;
send_mail_notice: procedure (my_noid);
declare my_noid bin(15);

     userptr->player.send_mail = false;

     call send_tih_msg (userptr->player.U_Q,
                'U' || byte(ASYNC_MSG) || byte(0) || byte(OBJECTSPEAK_$) ||
                 encode_byte(my_noid) || Mailmessage);


end send_mail_notice;
/* %page;
locate_player: procedure (which);
declare which       bin(31);
declare uno         bin(15);

declare 1 request,
          2 db_function  bin(15),
          2 player_id    bin(31);
declare request_str char(8) defined(request);

   uno = avatar.avatarslot;

   request.db_function = CC$dbf_locate_player;
   request.player_id   = which;

   call set_environment (UserList(uno), 0, 0);

   ...change this to go to habitatQ in case user is online...
   call send_message (habitat_dbQ, MSG$DB_LOOKUP, request_str, 6,
                      UserList(uno)->player.U_Id,RoomBQid);

end locate_player;
%page;
process_player_location: procedure(buff,uid);
declare buff             pointer;
declare 1 buff_olay      based (buff),
          2 function     bin(15),
          2 player_id    bin(31),
          2 whereabouts  bin(31);

declare uid bin(31);

   call check_request_info (uid,req$name_region,userptr);
   if (userptr = null()) then return;

   call chips_routine (buff_olay.whereabouts);

end process_player_location;
*/
%page;
close_container: procedure (noid);
declare noid          bin(15);

declare ep            pointer;
declare k             bin(15);

declare 1 contain based(selfptr) %include 'struct_gen_container';

   ep = ObjList(noid)->object.param1;
   if (Class_Table(ObjList(noid)->object.class).capacity ^= 0) then
   do k = 0 to Class_Table(ObjList(noid)->object.class).capacity-1;
      if (ep->element(k) ^= 0) then do;
         call reclaim_space (ObjList(ep->element(k)));
         current_region.object_count = current_region.object_count - 1;
         call my_free (ObjList(ep->element(k)));
         ObjList(ep->element(k)) = null();
         ep->element(k) = 0;
         end;
      end;

   /* Respond to the requester:  */

   call send_tih_msg (UserList(avatar.avatarslot)->player.U_Q,
                     'U' || current_header || encode_byte(current_noid) ||
                     encode_byte(current_request) || byte(SUCCESS));

   /* Notify all others:

   call Build_Fan_List (current_qid,false);
   if (fan_cnt = 0) then return;

   response = 'U' || byte(ASYNC_MSG)           ||
              encode_byte(avatar.noid) ||
              encode_byte(current_request)        ||
              encode_byte(selfptr->object.noid)   ||
              encode_byte(contain.open_flags);

   call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,substr(response,1),
                        length(response),0,0);
*/
end close_container;
%page;
process_enter_room: procedure (str,uid,qid);
declare str         character(*) varying;       /* screen name     */
declare uid         bin (31);                   /* user id number  */
declare qid         bin (31);                   /* queue id number */

declare (i,j)   binary (15);
declare version_str           character(2) defined(version);
declare version               binary (15);
declare object_cnt            binary (15);
declare object_cnt_str        char(2) defined(object_cnt);
declare screen_name           character(10) varying;
declare login_request         character(10) varying;
declare ei                    pointer;
declare uptr                  pointer;
declare chg_region_req        bit(1) aligned;

declare 1 result,
          2 code       bin(15),
          2 roomq      bin(31),
          2 rproc_num  bin(15);
declare result_str     char(8) defined (result);


     if (^RoomDBank.initialized) then do;
        if (BUGON) then call trace_msg ('Waiting for region initialization...');
        allocate enter_info set(ei);
        ei->enter_info.type     = 1;
        ei->enter_info.room     = RoomNumber;
        ei->enter_info.user     = uid;
        ei->enter_info.que      = qid;
        ei->enter_info.qc_name  = q_context.screen_name;
        ei->enter_info.qc_hold  = get_context_holding_area (CH$club_caribe);
        ei->enter_info.params   = str;
        call add_to_list (RoomDBank.waiting_list,ei);
        if (BUGON_high) then call trace_msg ('Add:  enter_info');
        return;
        end;

     if (substr(str,3,2) ^= '--') then do;
        call validate_change_request;
        return;
     end;

     version_str = substr(str,1,2);
     screen_name = rtrim(substr(str,5,10));
     login_request = substr(str,15);

     chg_region_req = (login_request = '');
     if (chg_region_req) then do;
        call GetPtr_by_uid (uid,uptr);
        if (uptr = null()) then do;
           call trace_msg ('Enter from unknown ' || ltrim(uid) || '/' ||
                           ltrim(q_context.uid)  || ':' || 
                           rtrim(q_context.screen_name) || ', region ' ||
                           ltrim(Region) || ' ' || str);
           return;
           end;
        uptr->player.U_Q_Id = qid;
        end;
        else do;
           call add_user_as_ghost (uid,qid,uptr);
           call request_mail_status (uptr);
           end;

     uptr -> player.U_Name        = screen_name;
     uptr -> player.U_version     = version;
     uptr -> player.incoming      = true; 

     call open_queue_from_number(qid,uptr->player.U_Q);
     call switch_queues (uptr);

     if (^chg_region_req) then do;
        call process_input (login_request,uid,qid);
        uptr->player.new_session   = true;
        uptr->player.ck_last_login = true;
        end;

     if (screen_name ^= substr(q_context.screen_name, 1, 10))
        then call trace_msg ('Initial name mismatch for ' || ltrim(uid) ||
                             ': ' || ltrim(screen_name) || '/' ||
                             ltrim(q_context.screen_name));

     return;

%page;
validate_change_request: procedure;

declare 1 request             based(rptr),
          2 region_num        bin(31),
          2 total_cnt         bin(15),
          2 ghost_flag        char(1),
          2 unused            char(1),
          2 objs(9)           bin(15),
          2 positions(9)      bin(15);
declare rptr pointer;

     rptr = addrel(addr(str),2);
     result.roomq = RoomBQid;
     result.rproc_num = process_number;
     result.code  = 0;

     if (RoomDBank.refuse_entry = true)
        then result.code = 1;

     if (request.ghost_flag = 'A') then do;
        if ((request.total_cnt + current_region.object_count) >= 
                                     CONCURRENT_OBJECTS)
           then result.code = 2;
        if (avatar_count() >= current_region.max_avatars)
           then result.code = 3;
        end;

     if (RoomDBank.private)
        then if (current_region.owner ^= uid  &  ^RoomDBank.owner_here)
        then result.code = 4;


/* NOTE: This should ALWAYS be the last check to determine if user can come */
/* into this region.  If it passes the space is reserved for the user to    */
/* come in.                                                                 */

     if (result.code = 0) then 
        if (^space_available(request.objs,request.positions)) then do; 
           result.code = 5;
           end;

     if (result.code ^= 0) then do;
        if (BUGON_high) then call trace_msg (ltrim(uid) ||
                 ':  chg region refused, mem = ' || 
                 ltrim(current_region.space_usage) || ', reason = ' ||
                 substr ('^recocntpcntprivheap',result.code,4));
        result.code = 1;
        call send_message (habitatQ, MSG$CHANGE_ROOM_RESULT, result_str,
                           8,uid,qid);
        call check_for_empty_region;
        return;
        end;

     current_region.object_count = current_region.object_count + 
                                   request.total_cnt;
     result.code = 0;
     if (BUGON_high) then call trace_msg (ltrim(uid) || 
                 ': OK to enter region ' || ltrim(Region));
     call send_message (habitatQ, MSG$CHANGE_ROOM_RESULT, result_str,
                        8,uid,qid);

     call prepare_for_backout;
     return;

%page;
prepare_for_backout: procedure;
declare p pointer;

     allocate mug_shot set(p);
     p->mug_shot.type      = 2;
     p->mug_shot.user      = uid;
     p->mug_shot.que       = qid;
     p->mug_shot.mail      = 0;
     p->mug_shot.obj_cnt   = request.total_cnt;
     p->mug_shot.obj_class = request.objs;
     p->mug_shot.obj_pos   = request.positions;
     call add_to_list (RoomDBank.waiting_list,p);
     if (BUGON_high) then call trace_msg ('ADD: mug_shot');

     RoomDBank.avatars_coming = RoomDBank.avatars_coming + 1;

end prepare_for_backout;
end validate_change_request;
end process_enter_room;
%page;
retry_user_enter: procedure (p);

declare p pointer;

     if (p->enter_info.type ^= 1) then do;
        call trace_msg ('Bad type in retry_user_enter: ' || 
                        ltrim(p->enter_info.type));
        return;
        end;

     RoomNumber = p->enter_info.room;
     RoomPtr    = RoomPtrs(RoomNumber);
     CapMonPtr  = CapMonPtrs(RoomNumber); 

     /*        Restore the important parts of q_context.    */
     q_context.uid          = p->enter_info.user;
     q_context.qid          = p->enter_info.que;
     q_context.screen_name    = p->enter_info.qc_name;
     call set_context_holding_area (CH$club_caribe, p->enter_info.qc_hold);

     call process_enter_room (p->enter_info.params,p->enter_info.user,
                              p->enter_info.que);

     free p -> enter_info;

end retry_user_enter;
%page;
add_user_as_ghost: procedure (uid,qid,up);
declare uid  binary(31);
declare qid  binary(31);
declare up   pointer;

    allocate player set (up);
    up->player.U_Name        = '';
    up->player.U_version     = 0;
    up->player.U_Id          = uid;
    up->player.U_Q           = null();
    up->player.U_Q_Id        = qid; 
    up->player.online        = false;
    up->player.incoming      = false;
    up->player.cr_pending    = false;
    up->player.ck_last_login = false;
    up->player.gagged        = false;
    up->player.object_slot   = GHOST;
    up->player.last_cmd      = '';

    up->player.has_mail      = false;
    up->player.send_mail     = false;
    up->player.last_mail_ts  = 0;

    up->player.esp.to_uid    = 0;
    up->player.esp.to_qid    = 0;
    up->player.esp.que       = null();

    call add_to_list (GhostList,up);
    total_ghosts = total_ghosts + 1;

end add_user_as_ghost;
%page;
request_mail_status: procedure (up);
declare up pointer;

declare 1 request,
          2 db_function  bin(15),
          2 avatar_id    bin(31);
declare request_str char(6) defined(request);
declare tp pointer;

   request.db_function = CC$dbf_check_mail;
   request.avatar_id   = up->player.U_Id;

   call set_environment (up, 0, 0);

   call send_message (habitat_dbQ, MSG$DB_LOOKUP, request_str, 6,
                         up->player.U_Id,RoomBQid);

end request_mail_status;
%page;
process_input: procedure (str, uid, qid); 
declare str              character(*) varying;
declare uid              binary (31);
declare qid              binary (31);
declare uno              binary (15);
declare command          binary (15);

declare 1 req            defined(str),
          2 char_cnt     bin(15),
          2 U_char       char(1),
          2 header       char(1),
          2 obj_id       char(1),
          2 function     char(1),
          2 parm1        char(1),
          2 parm2        char(1);
declare 1 hdr            defined(req.header),
          2 end_seq      bit(1),
          2 fill1        bit(1),
          2 start_seq    bit(1),
          2 fill2        bit(1),
          2 seq_number   bit(4);


     call GetUserPtr (qid,userptr);
     if (userptr = null()) then do;
        if (req.U_char = 'U' & 
                 substr(str,2,length(leave_region)) = leave_region) then do;
           call reroute_thru_habitat (str,uid,qid);
           return;
           end;
        else if (req.U_char = 'A') then return;   /* Chat msg could get here if we have delays */
        else call trace_msg ('Input from unknown ' || ltrim(string(uid)) ||
                             '/' || ltrim(Region) || ' ' || str);
        return;
     end;
     current_qid = qid;

     call decode_string (str);
     if (BUGON) then call trace_msg ('RCV: ' || str);

     if (req.U_char ^= 'U' & req.U_char ^= 'u') then do;
        call info_trace_msg ('Discard-' || ltrim(uid) || '/' || 
                            ltrim(Region) || ': ' || str);
        return;
        end;
     if (^hdr.start_seq | ^hdr.end_seq) then do;
        call handle_partial_request;
        return;
        end;

     request_string = substr(str,5);
     call process_request;
     return;

%page;
process_request: procedure;

declare cmd_offset(0:158) binary(15) static initial (1,
9, 24, 29, 40, 43, 48, 54, 0, 0, 58, 0, 63, 69, 0, 0, 75, 82, 87, 0, 93, 
98, 103, 109, 115, 121, 126, 131, 137, 143, 147, 153, 157, 164, 0, 169, 
174, 175, 182, 0, 0, 0, 183, 187, 192, 199, 205, 212, 219, 225, 0, 0, 
230, 0, 236, 243, 248, 249, 250, 0, 254, 259, 0, 0, 263, 0, 0, 0, 0, 268, 
0, 0, 0, 0, 269, 275, 280, 0, 0, 0, 286, 0, 287, 0, 292, 297, 303, 304, 
305, 311, 316, 321, 327, 328, 0, 329, 334, 341, 346, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 347, 
0, 355, 360, 361, 362, 363, 364, 365, 371, 376, 377, 378, 384, 389, 0, 
394, 395, 0, 0, 396, 0, 0, 397, 0, 403, 407, 408, 409, 415, 416, 417);
/*  cmd_tick array bounds must be 1:421. */
declare cmd binary(15);

     current_noid = rank(req.obj_id);
     current_request = rank(req.function);
     if ((current_noid ^= 0 & ObjList(current_noid) = null())  | 
         current_noid > OBJECTS_PER_REGION) then do;
        if (current_noid > last_noid  &  RoomDBank.noid_wrap = false  &
           current_noid ^= GHOST)
           then call force_user_dump ('Bad object id: ');
        return;
        end;

     selfptr         = ObjList(current_noid);
     avatarptr       = ObjList(userptr->player.object_slot);
     current_header  = req.header;
     if (current_request > Class_Table(selfptr->object.class).max_requests |
         Class_Table(selfptr->object.class).actions = null()) then do;
        call force_user_dump ('Bad request: ');
        return;
        end;

     call Class_Table(selfptr->object.class).actions->behavior(current_request);
     userptr->player.last_cmd = str;
     return;

end process_request;
%page;
handle_partial_request: procedure;
declare bp pointer;
declare 1 hold_buffer based,
          2 userq   bin(31),
          2 bytes   bin(15),
          2 data    char(644) var;

     if (hdr.start_seq = true) then do;
        allocate hold_buffer set (bp);
        bp->hold_buffer.userq = qid;
        bp->hold_buffer.bytes = length(str);
        bp->hold_buffer.data  = str;
        call add_to_list (partial_input,bp);
        return;
        end;

     call retrieve_previous_input (qid,bp);
     if (bp = null()) then do;
        call info_trace_msg ('Missing previous input for ' || ltrim(uid) ||
                              '/' || ltrim(Region));
        return;
        end;
     
     bp->hold_buffer.bytes = bp->hold_buffer.bytes + length(str) - 4;
     bp->hold_buffer.data  = bp->hold_buffer.data || substr(str,5);
     if (bp->hold_buffer.bytes > 646)
        then call info_trace_msg ('Partial buffer too big (' || 
                  ltrim(bp->hold_buffer.bytes) || ') for user ' || ltrim(uid) ||
                  '/' || ltrim(Region));

     if (hdr.end_seq = true) then do;
        call delete_from_list (partial_input,bp);
        str = substr(bp->hold_buffer.data,1,4);
        request_string = substr(bp->hold_buffer.data,5);
        free bp->hold_buffer;
        call process_request;
        end;
     return;

end handle_partial_request;
end process_input;
%page;
retrieve_previous_input: procedure (qid,ptr);
declare qid         bin(31);
declare ptr         pointer;
declare le          pointer;
declare done        bit(1);
declare partial_userq bin(31) based;

     le = partial_input;
     done = false;
     do while (^done & le ^= null());
        ptr = le->le_content;
        le = le->le_next;
        if (ptr->partial_userq = qid)
              then done = true;
     end;

     if (^done) then do;
        if (BUGON) then call trace_msg ('*ERR - No partial entry for ' || 
                   ltrim(qid) || '/' || ltrim(Region));
        ptr = null();
        end;

end retrieve_previous_input;
%page;
force_user_dump: procedure (tag);
declare tag char(*) var;
declare objects_class bin(15);

     if (ObjList(current_noid) = null())
        then objects_class = -1;
        else objects_class = ObjList(current_noid)->object.class;

     call trace_msg (tag ||
                     ' noid='         || ltrim(current_noid) ||
                     ' request='      || ltrim(current_request) || 
                     ' class='        || ltrim(objects_class) ||
                     ' region='       || ltrim(Region) ||
                     ' uid='          || ltrim(userptr->player.U_Id));
     call trace_msg ('Request data: ' || to_hex(request_string));

     call dump_host_environment;

     /*  Force user to dump - Fatal Error # 47   */
     call send_tih_msg (userptr->player.U_Q, 
                      'U' || byte(ASYNC_MSG) || byte(0) || byte(22));

end force_user_dump;
%page;
dump_host_environment: procedure;
declare work char(80) var;
declare i bin(15);

     call info_trace_msg ('Host: space_usage = ' || 
                          ltrim(current_region.space_usage));

     work = '';
     do i = 1 to GHOST;
        if (ObjList(i) ^= null()) then do;
           work = work || ltrim(i) || ':' || 
                  ltrim(ObjList(i)->object.class);
           if (ObjList(i)->object.class = 1)
               then work = work || '-' || ltrim(ObjList(i)->object.obj_id);
           work = work || ' ';
           if (length(work) > 55) then do;
               call info_trace_msg ('Host: ' || work);
               work = '';
               end;
           end;
        end;
     if (length(work) ^= 0) then call info_trace_msg ('Host: ' || work);

end dump_host_environment;
%page;
to_hex: procedure (data)  returns (char(80) var);
declare data      char(*) var;
declare work      char(80) var;
declare (chars,i) bin(15);
declare value     bin(31);

   chars = min(length(data),80);
   work  = '';
   do i = 1 to chars;
      value = rank(substr(data,i,1));
      work = work || hex(value,2);
      end;
   return (work);

end to_hex;
%page;
initialize_object_disk_patches: procedure;
declare  die             entry (bin(15), char(*) var, char(*) var);
declare port    bin(15);
declare (i,bc,code)  bin(15);

   call open_file ('CC_current_disk', port, SEQUENTIAL_FILE, 258, INPUT_TYPE,
                   IMPLICIT_LOCKING, SEQUENTIAL_MODE, '', code);
   if (code ^= 0) then call die (code,'Open', 'object disk file');

   do i = 1 to MAX_UPDATES;
      call s$seq_read (port,258,bc,disk_patch(i),code);
      if (code ^= 0) then call die (code,'initialize', 'object disk');
      end;

   call s$close (port,code);
   if (code ^= 0) then call debug_msg (code,'close of object disk file');
   call s$detach_port (port,code);

end initialize_object_disk_patches;
%page;
update_object_disk: procedure;
declare version char(1);
declare uno     bin(15);
declare p       pointer;

   version = substr(request_string,3,1);

   uno = avatar.avatarslot;
   call get_update_transaction (UserList(uno)->U_Q_Id,p);
   if (p = null()) 
      then call create_update_transaction (UserList(uno)->U_Q_Id,p);
    
   call next_track_sector_element (version,p->disk_update.which);
   if (p->disk_update.which = -1) then do;
      call delete_from_list (Updates,p);
      free p->disk_update;
      call send_region_contents;
      end;

   prefix = 'U' || byte(ASYNC_MSG) || encode_byte(0) /* 0 = region */ || 
             encode_byte(11) /* UPDATE command */;
   call encode_string (substr(disk_patch(p->disk_update.which),1), encoded);

   call send_multiple_packets (UserList(avatar.avatarslot),prefix,
                                    encoded,0,true);


end update_object_disk;
%page;
next_track_sector_element: procedure (vers,last);
declare vers   char(1);
declare last   bin(15);

/*   if (last = 0)      then last =  1;
     else if (last = 1) then last =  2;
     else if (last = 2) then last =  4;
     else if (last = 4) then last = -1;      */

     last = -1;     /* Shouldn't get here; if we do, just send region vector. */

end next_track_sector_element;
%page;
get_update_transaction: procedure (qid,ptr);
declare qid  bin(31);
declare ptr  pointer;

declare le               pointer;
declare done             bit(1);

     le = Updates;
     done = false;
     do while (^done & le ^= null());
        ptr = le->le_content;
        le = le->le_next;
        if (ptr->disk_update.qid = qid)
              then done = true;
     end;

     if (^done) then do;
        if (BUGON) then call trace_msg ('*ERR - No update entry for ' || 
                   ltrim(qid) || '/' || ltrim(Region));
        ptr = null();
        return;
        end;

end get_update_transaction;
%page;
create_update_transaction: procedure (qid,ptr);
declare qid    bin(31);
declare ptr    pointer;

   allocate disk_update set(ptr);

   ptr->disk_update.qid   = qid;
   ptr->disk_update.which = 0;

   call add_to_list (Updates,ptr);

end create_update_transaction;
%page;
send_region_contents: procedure;
declare ind         bin(15);
declare ghost_arrived bit(1) aligned;

declare money_bytes(4) char(1) defined (avatar.bank_account_balance);

%page;
   ghost_arrived = false;
/* content = byte(current_region.terrain) ||     */
   content = byte(0) || 
             byte(current_region.lighting + DayNight) ||
             byte(current_region.depth)   || byte(current_region.class_group);
   if (userptr->player.object_slot = GHOST & ObjList(GHOST) = null()) then do;
      call make_a_ghost;
      total_ghosts = 1;                /* total_ghosts + 1; chg 3/16/88 jdh */
      avatarptr = ObjList(GHOST);
      ghost_arrived = true;
      end;

   content = content || byte(avatar.noid) || money_bytes(4) ||
             money_bytes(3) || money_bytes(2) || money_bytes(1);

   databytes = '';
   ContList  = '';

   do ind = 1 to OBJECTS_PER_REGION;
      if (ObjList(ind) ^= null()) then do;
         if (ObjList(ind)->object.container = 0) then do;
            call build_vector_entry (ind);
            if (Class_Table(ObjList(ind)->object.class).capacity ^= 0)
               then call build_contents_list (ind,true);
            end;
         end;
      end;

   prefix = 'U' || current_header || encode_byte(current_noid) || 
             encode_byte(current_request);

   response = content || byte(0) || databytes || ContList;
   if (length(response) = 1) then response = '';
   call encode_string (response, encoded);

   if (length(prefix)+length(encoded) < 120) then do;
      call send_msg_var (userptr->player.U_Q, MSG$STOP_COMM,prefix || encoded);
      end;
   else call send_multiple_packets (userptr,prefix,encoded,0,false);

   userptr->player.online   = true;
   userptr->player.incoming = false;

   if (avatar.gr_state = 1  &  oracle.person = 0)
      then oracle.person = avatar.noid;

   if (userptr->player.U_Id = current_region.owner)
      then RoomDBank.owner_here = true;

   call Build_Fan_List (current_qid,false);
   if (ghost_arrived  & fan_cnt > 0) then do;
      content   = '';
      databytes = '';
      ContList  = '';
      call build_vector_entry (GHOST);
      call build_contents_list (GHOST,true);
      response = content || byte(0) || databytes || ContList;
      call encode_string (response,encoded);
      prefix    = 'U' || byte(ASYNC_MSG) || encode_byte(0) || encode_byte(8);
      if (BUGON) then call trace_msg ('HEREIS: ' || prefix || encoded);
      if (length(prefix)+length(encoded) < 120) then do;
         call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,prefix || encoded, 
                      length(prefix)+length(encoded),0,0);
         end;
      else call send_multiple_packets (null(),prefix,encoded,current_qid,true);
      end;

   if (userptr->player.new_session = true)
      then call new_session_postvector;

   return;

end send_region_contents;
%page;
build_vector_entry: procedure (ndx);
declare ndx         bin(15);
declare ptr         pointer; 

   content  = content || byte(ndx) || byte(ObjList(ndx)->object.class);

   if (Class_Table(ObjList(ndx)->object.class).capacity = 0)
      then ptr = addr(ObjList(ndx)->object.param1);
      else ptr = addr(ObjList(ndx)->object.param2);

   databytes = databytes || objects_data_descriptor (ndx,ptr);

end build_vector_entry;
%page;
build_contents_list: procedure (noid,noid_flag);
declare noid        bin(15);
declare noid_flag   bit(1);

declare ep          pointer;
declare ptr         pointer;
declare my_items    char(510) var;
declare my_data     char(1024) var;
declare i           bin(15);

   my_items = '';
   my_data  = '';
   ep = ObjList(noid)->object.param1;

   if (Class_Table(ObjList(noid)->object.class).capacity = 0) then return;

   do i = 0 to Class_Table(ObjList(noid)->object.class).capacity-1;
      if (ep->element(i) ^= 0) then do;
         my_items = my_items || byte(ep->element(i)) || 
                    byte(ObjList(ep->element(i))->object.class);

         if (Class_Table(ObjList(ep->element(i))->object.class).capacity = 0)
            then ptr = addr(ObjList(ep->element(i))->object.param1);
            else ptr = addr(ObjList(ep->element(i))->object.param2);

         my_data  = my_data || objects_data_descriptor (ep->element(i),ptr);
         end;
      end;

   if (my_items = '') then return;

   if (noid_flag)
      then ContList = ContList || byte(noid) || my_items || byte(0) || my_data;
      else ContList = ContList ||               my_items || byte(0) || my_data;

   if (Class_Table(ObjList(noid)->object.class).capacity ^= 0) then
   do i = 0 to Class_Table(ObjList(noid)->object.class).capacity-1;
      if (ep->element(i) ^= 0) then
         if (Class_Table(ObjList(ep->element(i))->object.class).capacity ^= 0)
            then call build_contents_list (ep->element(i),true);
      end;

end build_contents_list;
%page;
objects_data_descriptor: procedure (slot,ptr) returns (char(256) var);
declare slot   bin(15);
declare ptr    pointer;
declare (x_value,y_value) bin(15);

   if (ObjList(slot)->object.container = 0) 
      then do;
         x_value = ObjList(slot)->object.x;
         y_value = ObjList(slot)->object.y;
         end;
      else do;
         x_value = 0;
         y_value = ObjList(slot)->object.position;
         end;

   return (byte(ObjList(slot)->object.style)       ||
           byte(x_value)    || byte(y_value)       ||
           byte(ObjList(slot)->object.orientation) ||
           byte(ObjList(slot)->object.gr_state)    ||
           byte(ObjList(slot)->object.container)   ||
   state_elements(Class_Table(ObjList(slot)->object.class).pc_state_bytes,ptr));

end objects_data_descriptor;





state_elements: procedure (count,ptr) returns (char(80) var);
declare count bin(15);
declare ptr         pointer; 
declare i     bin(15);
declare state char(80) var;
declare state_info(80)  bin(15) based(ptr);

   state = '';
   do i = 1 to count;
      state = state || byte(state_info(i));
      end;

   return (state);

end state_elements;
%page;
new_session_postvector: procedure;
declare my_noid bin(15);

   userptr->player.new_session = false;
   my_noid = userptr->player.object_slot;

   if (Daymessage ^= '') then do;
      call send_tih_msg (userptr->player.U_Q,
                         'U' || byte(ASYNC_MSG) || byte(0) ||
                         byte(OBJECTSPEAK_$) || encode_byte(my_noid) ||
                         Daymessage);
      end;

   if (userptr->player.send_mail)
      then call send_mail_notice (my_noid);

end new_session_postvector;
%page;
check_last_login: procedure;
declare ap pointer;
declare 1 avatar based(ap)
%include 'struct_avatar';;

   userptr->player.ck_last_login = false;
   ap = ObjList(userptr->player.object_slot);
   avatar.gen_flags(MODIFIED) = true;

   if (avatar.last_login >= today_start_time) then do;
       call s$int_date_time (avatar.last_login);
       return;
       end;

   call s$int_date_time (avatar.last_login);
   avatar.bank_account_balance = avatar.bank_account_balance + 1;

end check_last_login;
%page;
calculate_today_start:  procedure (ptr);
declare  ptr        pointer;

declare  code       binary(15);
declare  cur_time   binary(31);
declare  wait_time  binary(31);
declare  date_stg   char(32) var;


   call s$int_date_time (cur_time);
   call s$cv_to_string_date_time (cur_time, date_stg);
   call s$cv_to_int_date_time (substr (date_stg, 1, 8), today_start_time, code);
   if (code ^= 0)  then  call debug_msg (code, date_stg);


/*    today is defined as starting at 10:00 am */
/*    reset this value each day    at 10:00 am */

   today_start_time = today_start_time - (14*60*60); /* previous day at 10:00 am */

   if (cur_time - today_start_time  >=  24*60*60)  then  /* after 10:00 am ?  */
       today_start_time = today_start_time + 24*60*60;   /* today at 10:00 am */

   wait_time = 24*60*60 - (cur_time - today_start_time);

   call Tact (calculate_today_start, null (), wait_time); /* wake up tomorrow */

end  calculate_today_start;

%page;
reroute_thru_habitat: procedure (str,uid,qid);
declare str char(*) var;
declare uid bin(31);
declare qid bin(31);

   call send_message (habitatQ,MSG$REROUTE,substr(str,1),
                      length(str),uid,qid);

end reroute_thru_habitat;
%page;
set_offline: procedure (uno);
declare uno bin(15);
declare why bin(15);
declare code bin(15);
declare kp_file char(256) var;

   if (BUGON) then call trace_msg ('User ' || 
                        ltrim(userptr->player.U_Id) || ' now offline');
   userptr->player.online   = false;
   userptr->player.incoming = false;

   why = rank(substr(request_string,1,1));
   if (why = 0) then return;

   if (BUGON) then do;
       call trace_msg ('>>>FE ' || ltrim(why) || ' in ' || ltrim(Region) ||
                   ', last request: ' || userptr->player.last_cmd);
       call dump_host_environment;
       end;

   return;

/* Compiler found the following to be unreachable; it's now commented out
   if (why ^= 11) then return;
   call s$expand_path ('region.FE11.kp','',kp_file,code);
   call s$create_keep_module (kp_file,null(),code);
   if (code ^= 0) then call debug_msg (code, 'FE11 kp file');
 */

end set_offline;
%page;
send_multiple_packets: procedure (uptr,prefix,info,exclude_qid,normal);
declare uptr        pointer;
declare prefix      char(*) var;
declare info        char(*) var;
declare exclude_qid bin(31);
declare normal      bit(1) aligned;

declare (first,sent,tobe_sent,maxdata,seg_len)    bin(15);
declare mtype       bin(31);
declare segment     char(256) var;

declare header_byte(4)  char(1) defined(prefix);  /* 2 c var len + 2nd byte */
declare header_bits(16) bit(1)  defined(header_byte(4));

   header_bits(1) = false;         /* END of sequence bit   */
   header_bits(2) = true;          /* Middle of sequence    */
   header_bits(3) = true;          /* START of sequence bit */

   sent      = 0;
   first     = 1;
   maxdata   = 119 - length(prefix);
   tobe_sent = length(info);
   mtype     = MSG$FRAME_START;

   if (uptr ^= null())
      then call start_packed_msg (uptr->player.U_Q, uptr->player.U_Id, 
                                  uptr->player.U_Q_Id);

   do while (sent < tobe_sent);
      if ( (tobe_sent - sent) <= maxdata) then do;
         if (normal)
            then mtype = MSG$FRAME_STOP;
            else mtype = MSG$FRAME_STOP_COMM;
         segment = substr(info,first);
         header_bits(1) = true;                   /* END-of-sequence bit */
         if (uptr ^= null()) then do;
            call send_packed_msg (uptr->player.U_Q,mtype,
                          prefix || segment, length(prefix)+length(segment),
                          0,uptr->player.U_Q_Id);
            call force_packed_msg (uptr->player.U_Q);
            end;
         else call send_fan_message(fan_list,fan_cnt,mtype,
                          prefix || segment,length(prefix)+length(segment),0,0);
         return;
         end;
      if (substr(info,(first+maxdata-1),1) = byte(93))
         then seg_len = maxdata - 1;
         else seg_len = maxdata;
      segment = substr(info,first,seg_len);
      first = first + seg_len;
      sent = sent + seg_len;
      if (uptr ^= null())
         then call send_packed_msg(uptr->player.U_Q,mtype,
                        prefix || segment, length(prefix)+length(segment),
                        0,uptr->player.U_Q_Id);
         else do;
              call send_fan_message(fan_list,fan_cnt,mtype,
                        prefix || segment,length(prefix)+length(segment),0,0);
              call Build_Fan_List (exclude_qid,false);
              end;
      header_bits(3) = false;                        /* START-of-sequence bit */
      mtype = MSG$FRAME_CONT;
      end;

end send_multiple_packets;
%page;
switch_queues:  procedure (uptr);
   declare  uptr                        pointer;

   declare  dummy                       char    (1)   based;
   declare  sm_ptr                      pointer static internal init (null());

   if (sm_ptr = null ()) then do;
       allocate switch_queue_msg   set (sm_ptr);
       sm_ptr -> switch_queue_msg.q_type = type$roomerQ;
       end;

   sm_ptr -> switch_queue_msg.qid = RoomQid;

   call send_message (uptr->player.U_Q, MSG$SWITCH_QUEUES,
                      sm_ptr -> dummy, bytesize (switch_queue_msg),
                      0, uptr->player.U_Q_Id);

end  switch_queues;

%page;
change_regions: procedure (who,rnumber,direction,transition);
declare who                   binary(15);
declare rnumber               binary(31);
declare direction             binary(15);
declare transition            binary(15);
declare uno                   bin(15);
declare (i,j,k)               bin(15);

declare 1 request,
          2 region_num        bin(31),
          2 total_cnt         bin(15),
          2 ghost_flag        char(1),
          2 unused            char(1),
          2 objs(9)           bin(15),
          2 positions(9)      bin(15);
declare request_stg           char(12) defined (request);

     request.region_num = rnumber;
     uno = ObjList(who)->object.avatarslot;
     call count_my_possessions (who,request.total_cnt,request.objs);

     if (who = GHOST)
        then request.ghost_flag = 'G';
        else do;
           request.ghost_flag = 'A';
           if (UserList(uno) = null()) then do;
              call trace_msg ('Null userptr in chg reg, user=' ||
                               ltrim(userptr->player.U_Id));
              return;
              end;
           userptr = UserList(uno);
           end;

     do i = 1 to 9;
        request.objs(i) = 0;
        request.positions(i) = 0;
        end;
     if (who ^= GHOST) then do;
        request.objs(1) = class_style (ObjList(who)->object.class,
                                       ObjList(who)->object.style);
        request.positions(1) = 0;
        j = 2;
        do i = 0 to 7;
           k = ObjList(who)->object.param1->element(i);
           if (k ^= 0) then do;
              request.objs(j) = class_style (ObjList(k)->object.class,
                                             ObjList(k)->object.style);
              request.positions(j) = 256 + i;
              j = j + 1;
              end;
           end;
        end;

     if (BUGON_high) then call trace_msg (ltrim(userptr->player.U_Id)
                     || ': change from ' || ltrim(Region) || ' to '
                     || ltrim(rnumber) || ' with '
                     || ltrim(request.total_cnt) || ' objects.');

     call set_environment (userptr, direction, transition);

     call send_message (habitatQ, MSG$CHANGE_ROOM, 
                        request_stg, bytesize(request),
                        userptr->player.U_Id, userptr->player.U_Q_Id);

     userptr->player.cr_pending = true;

end change_regions;
%page;
count_my_possessions: procedure (who,count,classes);
declare who     bin(15);
declare count   bin(15);
declare classes (*) bin(15);

declare ep pointer;
declare i bin(15);

   do i = 1 to dimension(classes,1);
      classes(i) = 0;
      end;

   if (who = GHOST) then do;
      count = 0;
      return;
      end;

   count = 1;       /* Always at least me */
   classes(count) = class_style (ObjList(who)->object.class,
                                 ObjList(who)->object.style);
   ep = ObjList(who)->object.param1;

   if (Class_Table(CLASS_AVATAR).capacity ^= 0) then
   do i = 0 to Class_Table(CLASS_AVATAR).capacity-1;
      if (ep->element(i) ^= 0) then
         if (Class_Table(ObjList(ep->element(i))->object.class).capacity ^= 0)
            then call count_contents (ep->element(i));
            else do;
               count = count + 1;
               classes(count) = class_style (ObjList(ep->element(i))->object.class,
                                         ObjList(ep->element(i))->object.style);
               end;
      end;

   return;

count_contents: procedure (obj) recursive;
declare obj              bin(15);
declare ep               pointer;
declare i                bin(15);

   count = count + 1;              /* For the container itself */
   ep = ObjList(obj)->object.param1;

   if (Class_Table(ObjList(obj)->object.class).capacity ^= 0) then
   do i = 0 to Class_Table(ObjList(obj)->object.class).capacity-1;
      if (ep->element(i) ^= 0) then
         if (Class_Table(ObjList(ep->element(i))->object.class).capacity ^= 0)
            then call count_contents (ep->element(i));
      end;

end count_contents;
end count_my_possessions;
%page;
class_style: procedure (the_class,the_style) returns (binary(15));
declare the_class   bin(15);
declare the_style   bin(15);

declare result      bin(15);
declare part(2)     char(1) defined(result);

   part(1) = byte(the_class);
   part(2) = byte(the_style);

   return (result);

end class_style;
%page;
process_users_objects: procedure (buff);
declare buff             pointer;
declare 1 obj            based(buff),
          2 mail_time    bin(31),
          2 count        bin(15),
          2 list_data(1013) char(1);
declare op pointer;
declare (i,j,umember) bin(15);
declare uptr          pointer;

     op = addr(obj.list_data(1));

     if (op->obj_desc.class = byte(CLASS_GHOST)) then do;
        call add_to_ghostlist (uptr,op->obj_desc.id);
        uptr->player.incoming = true;
        uptr->player.last_mail_ts = obj.mail_time;
        if (ObjList(GHOST) = null()) then
           call make_a_ghost;
        total_ghosts = total_ghosts + 1;
        if (BUGON_high) then call trace_msg (ltrim(uptr->player.U_Id)
                     || ': added to ' || ltrim(Region));
        return;
        end;

     do i = 1 to obj.count;
        if (op->obj_desc.class = byte(CLASS_AVATAR)) then do;
           call add_to_userlist (umember,op->obj_desc.id,4);
           if (BUGON_high) then call trace_msg (ltrim(op->obj_desc.id)
                     || ': added to ' || ltrim(Region));
           end;
        call next_available_noid(j);
        if (j < 0) then return;
        if (BUGON) then call trace_msg ('Adding noid: ' || ltrim(string(j)) || ' , class: ' ||
                       ltrim(rank(op->obj_desc.class)));
        call create_object_entry (op,j,false,false);
        if (op->obj_desc.class = byte(CLASS_AVATAR) & umember ^= 0) then do;
           UserList(umember)->player.object_slot = j;
           UserList(umember)->player.U_Name =
                                       rtrim(substr(op->obj_desc.props,1,10));
           UserList(umember)->player.last_mail_ts = obj.mail_time;
           end;

        op = addrel(op,op->obj_desc.prop_len+obj_fixed);
     end;

end process_users_objects;
%page;
add_to_ghostlist: procedure (uptr,userID);
declare uptr        pointer;
declare userID      bin(31);

    allocate player set (uptr);

    uptr->player.U_Name        = '';
    uptr->player.U_version     = 0;
    uptr->player.U_Id          = userID;
    uptr->player.U_Q           = null();
    uptr->player.U_Q_Id        = 0; 
    uptr->player.object_slot   = GHOST;
    uptr->player.has_mail      = false; 
    uptr->player.send_mail     = false; 
    uptr->player.online        = false; 
    uptr->player.incoming      = false;
    uptr->player.cr_pending    = false;
    uptr->player.ck_last_login = false;
    uptr->player.new_session   = false;
    uptr->player.gagged        = false;
    uptr->player.last_cmd      = '';

    uptr->player.esp.to_uid    = 0;    
    uptr->player.esp.to_qid    = 0;    
    uptr->player.esp.que       = null();

    call add_to_list (GhostList,uptr);

end add_to_ghostlist;
%page;
process_change_result: procedure (arg,uid,qid);
declare arg  pointer;
declare uid  bin(31);
declare qid  bin(31);
declare str  char(32) var;
declare op   pointer;
declare base   bin(15);
declare 1 result based(arg),
          2 code      bin(15),
          2 roomq     bin(31),
          2 rproc_num bin(15);
declare 1 obj,
          2 mail_time    bin(31),
          2 count        bin(15),
          2 list_data(1013) char(1);
declare obj_list         char(254) defined (obj);
declare (uno,my_noid)    bin(15);
declare other            bin(15);
declare regionq          pointer;
declare parameter        bin(15);
declare parameter_str    char(2) defined (parameter);
declare 1 cntl           ,
          2 dont_use     char(1),
          2 format       char(1),
          2 mod_flag     (8) bit(1),
          2 header       char(1),
          2 object_id    bin(15),
          2 function     bin(15),
          2 direction    bin(15),
          2 transition   bin(15),
          2 orientation  bin(15),
          2 from_region  bin(31);
declare cntl_buffer      char (20) defined (cntl);
declare cntl_mod_flag bit(8) defined (cntl.mod_flag);

declare change_region_fail entry(binary(15));

   call check_request_info (uid,req$change_region,userptr);
   if (userptr = null()) then do;
      call info_trace_msg ('No user on chg region result ' ||
                      ltrim(uid) || '/' || ltrim(Region));
      return;
      end;

   if (result.code ^= 0) then do;
      if (BUGON_high) then call trace_msg (ltrim(uid) || 
                      ': cannot change region, remaining in' ||
                      ltrim(Region));
      call change_region_fail(current_noid);
      call send_tih_msg (userptr->player.U_Q,
                    'U' || current_header || encode_byte(current_noid) ||
                    encode_byte(current_request) || byte(BOING_FAILURE));

      return;
      end;

%page;

   if (BUGON_high) then call trace_msg (ltrim(uid) || 
                   ': OK to change region, leaving, ' || ltrim(Region));

/* Must ask Chip about location of this call to ExitDaemon.  If it is here */
/* we cannot prevent user from taking something with him.  If it is before */
/* we will call ExitDaemon before we know if the user will be allowed to   */
/* actually go to the new region.  Do we need two classes?                 */

   if (current_region.exit_proc > 0) then
      if (current_region.exit_proc <= MAX_ExitDaemon)
         then call Daemons(current_region.exit_proc).ExitRoutine;
         else call trace_msg ('*ERR* Illegal exit proc for region ' ||
                              ltrim(Region));

   my_noid = userptr->player.object_slot;

   cntl_mod_flag = '00'b4;
   if (my_noid ^= GHOST) then do;
      call set_bit (ObjList(my_noid)->object.gr_state, 7);
      call lights_off (ObjList(my_noid));
      cntl.mod_flag(1) = ObjList(my_noid)->object.gen_flags(MODIFIED);
      other = ObjList(my_noid)->object.param1->element(HANDS);
      if (other ^= 0)
          then cntl.mod_flag(2) = ObjList(other)->object.gen_flags(MODIFIED);
      other = ObjList(my_noid)->object.param1->element(HEAD);
      if (other ^= 0)
          then cntl.mod_flag(3) = ObjList(other)->object.gen_flags(MODIFIED);
      end;
   cntl.mod_flag(4) = userptr->player.has_mail;
   cntl.mod_flag(5) = userptr->player.send_mail;
   cntl.mod_flag(6) = userptr->player.gagged;

   obj.mail_time = userptr->player.last_mail_ts;
   obj.count     = 0;
   base = 1;
   op = addr(obj.list_data(base));

   if (my_noid = oracle.person) then oracle.person = 0;

   if (my_noid = GHOST) 
      then ObjList(GHOST)->object.obj_id = userptr->player.U_Id;
   call create_descriptor (op,my_noid,my_noid,-1);
   obj.count = obj.count + 1;
   base = base + op->obj_desc.prop_len + obj_fixed;
   op = addr(obj.list_data(base));

   call add_description (my_noid);
   if (my_noid = GHOST) then ObjList(GHOST)->object.obj_id = 0;

   if (userptr->player.ck_last_login = true)
       then cntl.format = byte(3);
       else cntl.format = byte(1);
   cntl.header      = current_header;
   cntl.object_id   = current_noid;
   cntl.function    = current_request;
   cntl.orientation = current_region.orientation;
   cntl.from_region = Region;

   parameter_str   = substr(request_string,1,2);
   cntl.direction  = parameter;
   parameter_str   = substr(request_string,3,2);
   cntl.transition = parameter;
   call set_context_holding_area (CH$club_caribe, cntl_buffer);

   if (send_directly (result.rproc_num, result.roomq, regionq)) then
       call send_message (regionq, MSG$ADD_OBJECTS,
                          substr(obj_list,1,(base+5)),
                          (base+5), uid, userptr->player.U_Q_Id);
   else 
       call fake_send_msg (result.roomq,
                          substr(obj_list,1,(base+5)),
                          (base+5), uid, userptr->player.U_Q_Id);

   /* Tell everybody in old region that he left.        */

   userptr->player.online   = false;
   userptr->player.incoming = false;
   if (userptr->player.U_Id = current_region.owner)
      then RoomDBank.owner_here = false;

   if (my_noid ^= GHOST  |  ghost_count(1) = 0) then do;
      call Build_Fan_List (userptr->player.U_Q_Id,false);
      if (fan_cnt > 0) then do;
         str = 'U' || byte(ASYNC_MSG) || encode_byte(0) ||
               encode_byte(9) || encode_byte(my_noid);
         call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,substr(str,1),
                            length(str),0,0);
         end;
      call remove_object (my_noid);
      end;

   if (my_noid ^= GHOST) then do;
      call GetUserEntry (userptr->player.U_Q_Id,uno);
      if (uno ^= 0) 
         then UserList(uno) = null();
         else call dump_userlist;
      free userptr -> player;
      end;
   else do;
      call delete_from_list (GhostList,userptr);
      total_ghosts = total_ghosts - 1;
      if (ghost_count(1) = 0) then do;
         call my_free (ObjList(GHOST));
         ObjList(GHOST) = null();
         call Build_Fan_List (userptr->player.U_Q_Id,false);
         if (fan_cnt ^= 0) then do;
            response = 'U' || byte(ASYNC_MSG) || encode_byte(0) || 
                       encode_byte(9) || encode_byte(GHOST);
            call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,
                       substr(response,1),length(response),0,0);
            end;
         end;
      free userptr -> player;
      end;

   call check_for_empty_region;
   return;

add_description: procedure (noid); /* recursive; */
declare noid bin(15);
declare i    bin(15);

declare vary_st_len bin(15);
declare ep   pointer;

   ep = ObjList(noid)->object.param1;
   if (Class_Table(ObjList(noid)->object.class).capacity ^= 0) then
   do i = 0 to Class_Table(ObjList(noid)->object.class).capacity-1;
     if (ep->element(i) ^= 0) then do;
        vary_st_len =
            Class_Table(ObjList(ep->element(i))->object.class).class_bytes;
        call create_descriptor (op,ep->element(i),my_noid,vary_st_len);
        base = base + vary_st_len + obj_fixed;
        op = addr (obj.list_data(base));
        obj.count = obj.count + 1;
/*      if (Class_Table(ObjList(ep->element(i))->object.class).capacity ^= 0)
           then call add_description (ep->element(i));                     */
        end;
     end;

end add_description;
dump_userlist: procedure;
declare info char(80) var;
declare user bin(15);

     call trace_msg ('NO USERLIST ENTRY for ' || ltrim(userptr->player.U_Id) ||
                     ltrim(userptr->player.U_Q_Id));
     info = '';
     do user = 1 to USERS_PER_REGION;
        if (UserList(user) ^= null())
           then info = info || ltrim(user) || ':' || 
                       ltrim(UserList(user)->player.U_Id) || '/' ||
                       ltrim(UserList(user)->player.U_Q_Id) || ' ';
        end;
     call trace_msg ('UL: ' || info);
   
end dump_userlist;
end process_change_result;
%page;
send_directly: procedure (target_rproc, region_qid, region_q)
                          returns (bit(1) aligned);
declare target_rproc     bin(15);
declare region_qid       bin(31);
declare region_q         pointer;

     /* Check to see if we would be attempting to send to this process. */
     /* Since we are using direct queues, that is a no no.              */

     if (target_rproc = binary(process_number,15)) then return (false);

     call open_queue_from_number (region_qid, region_q);
     if (region_q = null()) then return (false);

     return (true);

end send_directly;
%page;
fake_send_msg: procedure (regn_q, buff, bytes, uid, qid);
declare regn_q      bin(31);
declare buff        char(*);
declare bytes       bin(31);
declare uid         bin(31);
declare qid         bin(31);
declare real_slot   bin(15);
declare i           bin(15);
declare found       bit(1) aligned;
declare (p1,p2,p3)  pointer;

     found = false;
     do i = REGIONS_PER_PROCESS to 1 by -1  while (^found);
        if (regn_q = RoomPtrs(i)->RoomBQid) then found = true;
        end;

     if (^found) then do;
        call trace_msg ('*ERR* Cannot find region slot in fake_send_msg.');
        return;
        end;

     real_slot = RoomNumber;
     p1 = userptr;
     p2 = selfptr;
     p3 = avatarptr;

     RoomNumber = i + 1;                     /* Switch environment to the */
     RoomPtr    = RoomPtrs(RoomNumber);      /* region that the user is   */
     CapMonPtr  = CapMonPtrs(RoomNumber);    /* going to.                 */

     call process_users_objects (addr(buff));
     call process_add_user (uid,qid);

     RoomNumber = real_slot;                 /* Switch environment back   */
     RoomPtr    = RoomPtrs(RoomNumber);      /* so we can clean up.       */
     CapMonPtr  = CapMonPtrs(RoomNumber);

     userptr   = p1;
     selfptr   = p2;
     avatarptr = p3;

end fake_send_msg;
%page;
ghost_count: procedure (type) returns (bin(15));
declare type   bin(15);
declare le     pointer;
declare ptr    pointer;
declare cnt    bin(15);

   le = GhostList;
   cnt = 0;

   do while (le ^= null());
      ptr = le->le_content;
      le  = le->le_next;
      if (ptr->player.online | ptr->player.incoming)
         then if (type = 1  |  type = 3)
              then cnt = cnt + 1;
              else;
         else if (type = 2  |  type = 3)
              then cnt = cnt + 1;
      end;

   return (cnt);

end ghost_count;




avatar_count: procedure returns (bin(15));
declare cnt    bin(15);
declare i      bin(15);

   cnt = RoomDBank.avatars_coming;

   do i = 1 to USERS_PER_REGION;
      if (UserList(i) ^= null())
         then cnt = cnt + 1;
      end;

   if (cnt > current_region.max_avatars) then
      call trace_msg ('WHOA! Too many avatars for ' || ltrim(Region) || ': ' ||
                      ltrim(cnt)); 
   return (cnt);

end avatar_count;
%page;
create_descriptor: procedure (p,id,own,st_len);
declare p      pointer;
declare id     bin(15);
declare own    bin(15);
declare st_len bin(15);
declare avatar_name char(10);

declare propsptr pointer;
declare state_values char(80) based(propsptr);

   p->obj_desc.id          = ObjList(id)->object.obj_id;
   p->obj_desc.class       = byte(ObjList(id)->object.class);
   p->obj_desc.contype     = byte(0);
   if (ObjList(id)->object.container = 0)
      then p->obj_desc.container = 0;
      else do;
         p->obj_desc.container = ObjList(ObjList(id)->object.container)->
                                                              object.obj_id;
         p->obj_desc.contype = byte(min(2,   /* avatar=1, everything else=2 */
                         ObjList(ObjList(id)->object.container)->object.class));
         end;
   p->obj_desc.position    = byte(ObjList(id)->object.position);
   p->obj_desc.x_pos       = ObjList(id)->object.x;
   p->obj_desc.y_pos       = byte(ObjList(id)->object.y);
   p->obj_desc.style       = byte(ObjList(id)->object.style);
   p->obj_desc.orientation = byte(ObjList(id)->object.orientation);
   p->obj_desc.graph_state = byte(ObjList(id)->object.gr_state);
   p->obj_desc.graph_width = byte(ObjList(id)->object.gr_width);
   p->obj_desc.gen_flags   = ObjList(id)->object.gen_flags;
   if (st_len = -1)
      then st_len = Class_Table(ObjList(id)->object.class).class_bytes;
   if (Class_Table(ObjList(id)->object.class).capacity = 0)
      then propsptr = addr(ObjList(id)->object.param1);
      else propsptr = addr(ObjList(id)->object.param2);
   p->obj_desc.prop_len  = st_len;
   if (p->obj_desc.class = byte(CLASS_AVATAR))
      then do;
         if (id = GHOST)
            then avatar_name = '';
         else do;
            avatar_name = UserList(ObjList(id)->object.avatarslot)->U_Name;
            end;
         substr(p->obj_desc.props,1,st_len) = avatar_name ||
                                              substr(state_values,1,st_len-10);
      end;
   else
      substr(p->obj_desc.props,1,st_len) = substr(state_values,1,st_len);

end create_descriptor;
%page;
remove_object: procedure (noid) recursive;
declare noid bin(15);

declare doid bin(15);
declare i    bin(15);
declare ep   pointer;

   doid = noid;

   if (doid = GHOST) then do;
      call my_free (ObjList(GHOST));
      ObjList(GHOST) = null();
      return;
      end;

   if (Class_Table(ObjList(doid)->object.class).capacity ^= 0) then do;
   ep = ObjList(doid)->object.param1;
   do i = 0 to Class_Table(ObjList(doid)->object.class).capacity-1;
     if (ep->element(i) ^= 0) then do;
        if (Class_Table(ObjList(ep->element(i))->object.class).capacity ^= 0)
           then call remove_object (ep->element(i));
           else if (ObjList(ep->element(i)) ^= null()) then do;
              if (BUGON) then call trace_msg('Removing noid ' || 
                                             ltrim(string(ep->element(i))));
              if (ep->element(i) = 0) then signal error;
              if (Class_Table(ObjList(ep->element(i))->object.class).capacity ^= 0)
                then do;
                call my_free (ObjList(ep->element(i))->object.param1);
                end;
              if (ObjList(ep->element(i))->object.noid = oracle.object)
                 then do;
                     oracle.object = 0;
                     if (oracle.control ^= null())
                        then call cancel_oracle_timer;
                     end;
              call reclaim_space (ObjList(ep->element(i)));
              call my_free (ObjList(ep->element(i)));
              ObjList(ep->element(i)) = null();
              current_region.object_count = current_region.object_count - 1;
              end;
        end;
   end;
   end;

   if (BUGON) then call trace_msg('Removing noid ' || ltrim(string(doid)));
   if (doid = 0) then signal error;
   if (Class_Table(ObjList(doid)->object.class).capacity ^= 0) then do;
      call my_free (ObjList(doid)->object.param1);
      end;
   i = ObjList(doid)->object.container;
   if (i ^= 0) then do;
      ep = ObjList(i)->object.param1;
      ep->element(ObjList(doid)->object.position) = 0;
      end;
   if (ObjList(doid)->object.noid = oracle.object) then do;
      oracle.object = 0;
      if (oracle.control ^= null())
         then call cancel_oracle_timer;
      end;
   if (ObjList(doid)->object.noid = oracle.person)
      then oracle.person = 0;
   call reclaim_space (ObjList(doid));
   call my_free (ObjList(doid));
   ObjList(doid) = null();
   current_region.object_count = current_region.object_count - 1;

end remove_object;
%page;
disappear_object: procedure (which);
declare which bin(15);

   ObjList(which)->object.gen_flags(MODIFIED) = true;
   call checkpoint_object (DEAD_REGION,which);      /* was LIMBO... */
   call remove_object (which);                      /* need to replace calls */

end disappear_object;
%page;
destroy_object: procedure (which);
declare which bin(15);

   ObjList(which)->object.gen_flags(MODIFIED) = true;
   call checkpoint_object (DEAD_REGION,which);
   call remove_object (which);

end destroy_object;
%page;
create_object: procedure (ocls,osty,ox,oy,opos,oorient,ogrst,ocontain) 
                                                              returns (pointer);

declare (ocls,osty,ox,oy,opos,oorient,ogrst,ocontain) bin(15);
declare (j,k)                 bin(15);
declare propsptr              pointer;
declare max_contents          bin(15);
declare allocation            bin(31);
declare new_obj(1)            bin(15);
declare cont_class(1)         bin(15);
declare bits                  bin(15);

     if (ocls = CLASS_AVATAR | ocls = CLASS_REGION | ocls = CLASS_GHOST) then do;
        call trace_msg('*ERR: Attempt to create region or avatar object - region='
                        || ltrim(Region) || ', user=' || 
                        ltrim(userptr->player.U_Id));
        return (null());
        end;

     call next_available_noid (j);
     if (j < 0) then return (null());

     new_obj(1) = class_style(ocls,osty);
     cont_class(1) = ObjList(ocontain)->object.class * 256;
     if (^space_available(new_obj,cont_class)) then do;
/*      call trace_msg('Insufficient mem to create class ' || ltrim(ocls) ||
                  '/' || ltrim(osty) || ' in region ' || ltrim(Region)); */
        return (null());
        end;

     allocation = Class_Table(ocls).alloc_size;
     if (allocation < size(object)-40) then do;
         call trace_msg ('Class_Table.alloc_size is < min for class ' ||
                          ltrim(string(ocls)));
         allocation = size(object) - 40;
         end;
     call my_allocate (allocation,ObjList(j));

     ObjList(j)->object.noid        = j;
     ObjList(j)->object.obj_id      = global_id(object_id_type);
     ObjList(j)->object.class       = ocls;
     ObjList(j)->object.container   = ocontain;
     ObjList(j)->object.position    = opos;
     ObjList(j)->object.x           = ox;
     ObjList(j)->object.y           = oy;
     ObjList(j)->object.style       = osty;
     ObjList(j)->object.orientation = oorient;
     ObjList(j)->object.gr_state    = ogrst;
     ObjList(j)->object.gr_width    = 0;
     ObjList(j)->object.avatarslot  = 0;

     do bits = 1 to 32;
          ObjList(j)->object.gen_flags(bits) = false;
          end;
     ObjList(j)->object.gen_flags(MODIFIED) = true;

     if (ocontain ^= 0) 
        then call add_to_containers_list(ObjList(j)->object.container,j,
                                         opos);

     max_contents = Class_Table(ocls).capacity;
     if (max_contents = 0)
        then propsptr = addr(ObjList(j)->object.param1);
        else do;
           propsptr = addr(ObjList(j)->object.param2);
           call my_allocate ((max_contents * 16), ObjList(j)->object.param1);
           do k = 0 to max_contents-1;
              ObjList(j)->object.param1->element(k) = 0;
              end;
           end;

     current_region.object_count = current_region.object_count + 1;

     return (ObjList(j));

end create_object;
%page;
global_id: procedure (which) returns(bin(31));

declare s$notify_path entry (char(256) var, bin(31), bin(15));
declare s$sleep       entry (bin(31), bin(15));

declare which       bin(15);
declare my_process  bin(15);
declare new_id      bin(31);
declare code        bin(15);

   my_process = binary(process_number,15);

   if (my_process < 0  | my_process > MAX_PROCESSES) then do;
      call trace_msg ('BAD process_number : ' || ltrim(my_process));
      return (-1);
      end;

   if (which = object_id_type)
      then new_id = next.object_id(my_process);
      else new_id = next.text_id(my_process);

   do while (new_id = 0);
      call s$notify_path (shared_file_path,0,code);
      if (code ^= 0) then call debug_msg (code,'trying to notify shared memory');
      call s$sleep (5,code);       /* sleep for 5/1024 of a second */
      if (which = object_id_type)
         then new_id = next.object_id(my_process);
         else new_id = next.text_id(my_process);
      end;

   if (which = object_id_type)
      then next.object_id(my_process) = 0;
      else next.text_id(my_process)   = 0;

   call s$notify_path (shared_file_path,0,code);
   if (code ^= 0) then call debug_msg (code,'trying to notify shared memory');

   return (new_id);

end global_id;
%page;
space_available: procedure (obj_desc,obj_pos) returns(bit(1) aligned);
declare obj_desc(*) bin(15);
declare obj_pos(*)  bin(15);
declare the_class   bin(15);
declare the_style   bin(15);
declare cont_class  bin(15);
declare cont_pos    bin(15);
declare space_ok    bit(1) aligned;
declare (i,j)       bin(15);

   space_ok = true;
   do i = 1 to dimension(obj_desc,1) while (space_ok);
      if (obj_desc(i) ^= 0) then do;
         call extract_nibbles (obj_desc(i),the_class,the_style);
         call extract_nibbles (obj_pos(i),cont_class,cont_pos);
         if (container_is_opaque (cont_class,cont_pos))
            then call note_instance_creation (the_class,the_style);
            else call note_object_creation (the_class,the_style);
         space_ok = mem_checks_ok (the_class);
         end;
      end;

   if (space_ok) then return (true);

   do j = 1 to (i-1);
      if (obj_desc(j) ^= 0) then do;
         call extract_nibbles (obj_desc(j),the_class,the_style);
         call extract_nibbles (obj_pos(j),cont_class,cont_pos);
         if (container_is_opaque (cont_class,cont_pos))
            then call note_instance_deletion (the_class,the_style);
            else call note_object_deletion (the_class,the_style);
         end;
      end;

   return (false);

end space_available;
%page;
reclaim_space: procedure (optr);
declare optr   pointer;
declare cont_class bin(15);
declare cont_pos   bin(15);

  cont_class = ObjList(optr->object.container)->object.class;
  cont_pos   = optr->object.position;
  if (container_is_opaque (cont_class,cont_pos))
      then call note_instance_deletion (optr->object.class,optr->object.style);
      else call note_object_deletion (optr->object.class,optr->object.style);

end reclaim_space;
%page;
extract_nibbles: procedure (encoded,high_byte,low_byte);
declare encoded     bin(15);
declare high_byte   bin(15);
declare low_byte    bin(15);

declare part(2)     char(1) defined (encoded);

   high_byte = rank(part(1));
   low_byte  = rank(part(2));

end extract_nibbles;
%page;
process_add_user: procedure (uid,qid);
declare uid    bin(31);
declare qid    bin(31);

declare uptr   pointer;
declare msp    pointer;

declare users_version char(2) defined(q_context.version);

declare cntl_buffer  char(18);
declare 1 cntl           defined (cntl_buffer),
          2 dont_use     char(1),
          2 format       char(1),
          2 mod_flag     (8) bit(1),
          2 header       char(1),
          2 object       bin(15),
          2 function     bin(15),
          2 direction    bin(15),
          2 transition   bin(15),
          2 orientation  bin(15),
          2 from_region  bin(31);
declare cntl_format_bit(8) bit(1) defined(cntl.format);

declare str    char(32) var;
declare (me,other) bin(15);

   cntl_buffer = get_context_holding_area (CH$club_caribe);
   
   str = users_version || '--' || q_context.screen_name;
   call process_enter_room (str,uid,qid);
   call GetUserPtr (qid,uptr);
   if (uptr = null()) then do;
      if (BUGON_high)
         then call trace_msg ('add_user: user index = 0 for ' ||
                              ltrim(uid) || '/' || ltrim(qid) || 'in region ' ||
                              ltrim(Region));
      return;
      end;

   if (cntl_format_bit(7) = true) then uptr->player.ck_last_login = true;
   call send_tih_msg (uptr->U_Q, 
                      'U' || cntl.header || encode_byte(cntl.object) || 
                      encode_byte(cntl.function) || byte(SUCCESS));


   avatarptr = ObjList(uptr->player.object_slot);
   userptr   = uptr;
   call region_entry_daemon (cntl.direction,cntl.transition,cntl.orientation,
                             cntl.from_region);

   me = uptr->player.object_slot;
   if (me ^= GHOST) then do;
      ObjList(me)->object.gen_flags(MODIFIED) = cntl.mod_flag(1);
      other = ObjList(me)->object.param1->element(HANDS);
      if (other ^= 0) then 
          ObjList(other)->object.gen_flags(MODIFIED) = cntl.mod_flag(2);
      other = ObjList(me)->object.param1->element(HEAD);
      if (other ^= 0) then 
          ObjList(other)->object.gen_flags(MODIFIED) = cntl.mod_flag(3);
      call checkpoint_object (NULL_REGION,me);
      end;
   uptr->player.has_mail  = cntl.mod_flag(4);
   uptr->player.send_mail = cntl.mod_flag(5);
   uptr->player.gagged    = cntl.mod_flag(6);

   if (current_region.entry_proc > 0) then
      if (current_region.entry_proc <= MAX_EntryDaemon)
         then call Daemons(current_region.entry_proc).EntryRoutine;
         else call trace_msg ('*ERR* Illegal entry proc for region ' ||
                              ltrim(Region));

   if (user_on_waiting_list (qid,msp)) 
      then call remove_incoming_user (msp);
      else call trace_msg ('No waiting list entry for ' || ltrim(uid));

   /* Let everybody else know this guy came in... */

   call Build_Fan_List (qid,false);
   if (fan_cnt = 0) then return;

   if (me = GHOST)
      then if (ghost_count(1) > 1) then return;

   prefix    = 'U' || byte(ASYNC_MSG) || encode_byte(0) || encode_byte(8);
   content   = '';
   databytes = '';
   ContList  = '';

   call build_vector_entry (me);
   call build_contents_list (me,true);

   response = content || byte(0) || databytes || ContList;
   call encode_string (response,encoded);

   if (length(prefix)+length(encoded) < 120) then do;
      if (BUGON) then call trace_msg ('HEREIS: ' || prefix || encoded);
      call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,prefix || encoded, 
                      length(prefix)+length(encoded),0,0);
      end;
   else call send_multiple_packets (null(),prefix,encoded,qid,true);

end process_add_user;
%page;
entry_turn_nude: procedure;

     if (avatar.noid = GHOST) then return;

     avatar.customize(1) = 34;
     avatar.customize(2) = 32;
     avatar.gen_flags(MODIFIED) = true;
/*
     call Build_Fan_List (UserList(avatar.avatarslot)->U_Q_Id,true);
     if (fan_cnt = 0) then return;

     response = 'U' || byte(ASYNC_MSG) || byte(0) || byte(FIDDLE_$) ||
                byte(C64_customize_offset) || byte(2) ||
                byte(avatar.customize(1)) || byte(avatar.customize(2));
     call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,substr(response,1),
                           length(response),0,0);
*/
end entry_turn_nude;
%page;
entry_return_from_nude: procedure;

     if (avatar.noid = GHOST) then return;

     avatar.customize(1) = avatar.true_custom(1);
     avatar.customize(2) = avatar.true_custom(2);
     avatar.gen_flags(MODIFIED) = true;
/*
     call Build_Fan_List (UserList(avatar.avatarslot)->U_Q_Id,true);
     if (fan_cnt = 0) then return;

     response = 'U' || byte(ASYNC_MSG) || byte(0) || byte(FIDDLE_$) ||
                byte(C64_customize_offset) || byte(2) ||
                byte(avatar.customize(1)) || byte(avatar.customize(2));
     call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,substr(response,1),
                           length(response),0,0);
*/
end entry_return_from_nude;
%page;
remove_incoming_user: procedure (mp);
declare mp pointer;

   if (mp->mug_shot.mail = 1) then do;
      userptr->player.has_mail  = true;
      userptr->player.send_mail = true;
      end;

   call delete_from_list (RoomDBank.waiting_list,mp);
   if (BUGON_high) then call trace_msg ('DEL: mug_shot for ' ||
                                        ltrim(mp->mug_shot.user));
   free mp->mug_shot;

   RoomDBank.avatars_coming = RoomDBank.avatars_coming - 1;

end remove_incoming_user;
%page;
process_changeroom_fail: procedure (uid,qid);
declare uid              binary (31);
declare qid              binary (31);
declare str              character(32) var;
declare change_region_fail entry(binary(15));

     if (BUGON_high) then call trace_msg (ltrim(uid) || 
                     ': change failed, remaining in ' ||
                     ltrim(Region));

     call check_request_info (uid,req$change_region,userptr);
     if (userptr = null()) then do;
        call info_trace_msg ('Can''t find user on change fail: '
                        || ltrim(uid) || '/' || ltrim(Region));
        return;
        end;

     userptr->player.cr_pending = false;
   
     call change_region_fail(current_noid);
     call send_tih_msg (userptr->player.U_Q,
                        'U' || current_header || encode_byte(current_noid) ||
                        encode_byte(current_request) || byte(FAILURE));


     return;

end process_changeroom_fail;
%page;
request_player_list: procedure (prefix);
declare prefix    char(10) var;
declare curr_time bin(31);

     call set_environment (userptr, 0, 0);

     call send_message (habitatQ, MSG$USER_STATS, (prefix),
             length(prefix), userptr->player.U_Id,userptr->player.U_Q_Id);

end request_player_list;
%page;
format_player_list: procedure (buff);
declare buff        pointer;
declare 1 buf based (buff),
          2 pos     bin(15),
          2 name    (12) char(10);

declare (i,j,k)     bin(15);

     call s$int_date_time (now_in.last);

     if (buf.pos = 0) then do;
        now_in.count = 0;
        return;
        end;

     j = 0;
     k = 0;
     response = '';
     do i = 1 to buf.pos;
        response = response || buf.name(i) || '   ';
        j = j + 1;
        if (j = 3  |  i = buf.pos) then do;
           k = k + 1;
           response = substr(response,1,(length(response)-3));
           call encode_string (response, now_in.line(k));
           response = '';
           j = 0;
           end;
        end;

     now_in.count = k;

end format_player_list;
%page;
send_latest_players: procedure (uid,qid);
declare uid         binary (31);
declare qid         binary (31);

declare (i,j)     bin(15);

     call check_request_info (uid,req$list_players,userptr);
     if (userptr = null()) then return;

     call start_packed_msg (userptr->player.U_Q, userptr->player.U_Id, 
                                  userptr->player.U_Q_Id);

     response = 'U' || byte(ASYNC_MSG) || encode_byte(0) || 
                encode_byte(OBJECTSPEAK_$) || encode_byte(avatar.noid);

     if (now_in.count = 0) then 
        call send_tih_msg_packed (userptr->player.U_Q, response ||
                                   'None found.');
     else do i = 1 to now_in.count;
        encoded = response || now_in.line(i);
        call send_tih_msg_packed (userptr->player.U_Q, encoded);
        end;

     call send_tih_msg_packed (userptr->player.U_Q,
                     'U' || current_header || encode_byte(current_noid) ||
                     encode_byte(current_request) || byte(SUCCESS));
     call force_packed_msg (userptr->player.U_Q);

end send_latest_players;
%page;
identify_players_here: procedure  returns(bit(1) aligned);
declare (i,j)     bin(15);
declare name_list char(78) var;
declare more      bit(1) aligned;

     if ( ^privileged_user() ) then return (false);

     call start_packed_msg (userptr->player.U_Q, userptr->player.U_Id, 
                                  userptr->player.U_Q_Id);

     response = 'U' || byte(ASYNC_MSG) || encode_byte(0) || 
                encode_byte(OBJECTSPEAK_$) || encode_byte(avatar.noid);

     name_list = '';
     do i = 1 to 6;
        if (UserList(i) ^= null()) 
           then name_list = name_list || blank_fill(UserList(i)->player.U_Name);
        end;        

     more = true;
     do i = 1 to 2  while(more);
        if (length(name_list) > 39) then do;
           encoded = response || substr(name_list,1,36);
           name_list = substr(name_list,40);
           end;
        else do;
           encoded = response || substr(name_list,1,length(name_list)-3);
           more = false;
           end;
        call send_tih_msg_packed (userptr->player.U_Q, encoded);
        end;

     call send_tih_msg_packed (userptr->player.U_Q,
                    'U' || current_header || encode_byte(current_noid) ||
                     encode_byte(current_request) || byte(SUCCESS));

     call force_packed_msg (userptr->player.U_Q);
     return (true);

end identify_players_here;


blank_fill:  procedure (short_name) returns(char(13));
declare short_name char(*) var;
declare norm_name  char(13);

     norm_name = short_name;
     return (norm_name);

end blank_fill;
%page;
show_heap_usage: procedure  returns(bit(1) aligned);
declare (i,j)     bin(15);

     if (^q_context.user_group.internal) then return (false);

     call start_packed_msg (userptr->player.U_Q, userptr->player.U_Id, 
                                  userptr->player.U_Q_Id);

     encoded = 'U' || byte(ASYNC_MSG) || encode_byte(0) || 
              byte(OBJECTSPEAK_$) || encode_byte(avatar.noid) ||
              'Space usage: ' || ltrim(C64_HEAP_SIZE) || '-' ||
              ltrim(space_usage) || '=' || ltrim(C64_HEAP_SIZE - space_usage);

     call send_tih_msg_packed (userptr->player.U_Q, encoded);

     call send_tih_msg_packed (userptr->player.U_Q,
                    'U' || current_header || encode_byte(current_noid) ||
                     encode_byte(current_request) || byte(SUCCESS));

     call force_packed_msg (userptr->player.U_Q);
     return (true);

end show_heap_usage;
%page;
identify_teleport: procedure (teleport);
declare teleport  char(20) var;
declare uno       bin(15);

declare 1 request,
          2 db_function  bin(15),
          2 teleport_num char(20);
declare request_str char(22) defined(request);

   uno = avatar.avatarslot;

   request.db_function  = CC$dbf_locate_teleport;
   request.teleport_num = teleport;

   call set_environment (UserList(uno), 0, 0);

   call send_message (habitat_dbQ, MSG$DB_LOOKUP, request_str, 22,
                      UserList(uno)->player.U_Id,RoomBQid);

end identify_teleport;
%page;
process_teleport: procedure(buff,uid);
declare buff             pointer;
declare 1 buff_olay      based (buff),
          2 function     bin(15),
          2 global_id    bin(31),
          2 region       bin(31),
          2 x_coord      bin(15),
          2 y_coord      bin(15);

declare uid bin(31);

   call check_request_info (uid,req$get_teleport,userptr);
   if (userptr = null()) then return;              /* Requester has departed */

   call activate_teleporter (buff_olay.region,
                           buff_olay.x_coord,buff_olay.y_coord);

end process_teleport;
%page;
process_unplugged: procedure (uid,qid);
declare uid              binary (31);
declare qid              binary (31);
declare uno              binary (15);
declare uptr             pointer;
declare tptr             pointer;
declare my_noid          binary (15);

     if (BUGON) then call trace_msg ('Disconnect for ' || ltrim(uid) ||
                     '/' || ascii_qid(qid) || ' from region ' || ltrim(Region));
     my_noid = 0;
     call FindUser (qid,uptr);
     if (uptr ^= null()) then do;
        call check_exit_status (uptr);
        uptr->player.U_version  = 0;
        uptr->player.U_Q        = null();
        uptr->player.U_Q_Id     = 0; 
        uptr->player.online     = false; 
        uptr->player.incoming   = false;
        if (uptr->player.U_Id = current_region.owner)
           then RoomDBank.owner_here = false;
        my_noid = uptr->player.object_slot;
        if (my_noid = oracle.person) then oracle.person = 0;
        if (my_noid = GHOST   &  ghost_count(1) = 0) then do;
           call my_free (ObjList(GHOST));
           ObjList(GHOST) = null();
           end;
        if (my_noid ^= GHOST)
           then call drop_restricted_object (my_noid);
        call Build_Fan_List (uptr->player.U_Q_Id,false);
        if (fan_cnt ^= 0) then do;
           if (my_noid = GHOST)
           then if (ghost_count(1) = 0) then do;
              response = 'U' || byte(ASYNC_MSG) || encode_byte(0) || 
                         encode_byte(9) || encode_byte(GHOST);
              call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,
                         substr(response,1),length(response),0,0);
              end;
              else; /* still ghosts here - do nothing */
           else do;  /* not a ghost - avatar disappears */
              response = 'U' || byte(ASYNC_MSG) || encode_byte(0) || 
                         encode_byte(9) || encode_byte(my_noid);
              call send_fan_message(fan_list,fan_cnt,MSG$NORMAL,
                         substr(response,1),length(response),0,0);
              end;
           end;

        if (my_noid = GHOST)
           then call checkpoint_current_region (uptr->player.U_Id);
        if (my_noid ^= GHOST  &  total_ghosts < 200) then
        if (/* ObjList(my_noid)->object.gr_state ^= 1 */ true) then do;
           uno = ObjList(uptr->player.object_slot)->object.avatarslot;
           ObjList(my_noid)->object.x = -1;
           if (ObjList(my_noid)->object.container ^= 0) then do;
              tptr = ObjList(ObjList(my_noid)->object.container)->object.param1;
              tptr->element(ObjList(my_noid)->object.position) = 0;
              ObjList(my_noid)->object.container = 0;
              end;
           ObjList(my_noid)->object.gen_flags(MODIFIED) = true;
           call checkpoint_object (0,my_noid);
           uptr->player.object_slot = GHOST;
           total_ghosts = total_ghosts + 1;
           call add_to_list (GhostList,uptr);
           if (uno ^= 0) then UserList(uno) = null();
           call remove_object (my_noid);
           end;

        if (uptr->player.cr_pending) then do;
/*         call trace_msg ('Disconnect while changing region: ' ||
                     ltrim(uptr->player.U_Id) || '/' || ltrim(Region));  */
           uptr->player.cr_pending = false;
           end;
        if (uptr->player.ck_last_login) then do;
/*         call trace_msg ('Ghost-only session for ' ||
                          ltrim(uptr->player.U_Id));        */
           uptr->player.cr_pending = false;
           end;
     end;
     else if (user_on_waiting_list (qid,uptr)) 
          then call backout_incoming_avatar (uptr);
     else call trace_msg ('No unplugged user: ' || ltrim(uid) || '/' ||
                         ltrim(qid) || ' in Region ' || ltrim(Region));

     call check_for_empty_region;

end process_unplugged;
%page;
check_exit_status: procedure (uptr);
declare uptr pointer;

     if (uptr->player.online   = false &
         uptr->player.incoming = false ) then return;  /* Shift Run/Stop */

     return;
/* Compiler found the following to be unreachable; it's now commented out

     call send_msg_var (uptr->player.U_Q, MSG$DUMP_CIRCULAR, byte(32));

     call trace_msg ('Disc (' || uptr->player.last_cmd || ') leaving ' ||
                    ltrim(Region) || ', on ' || ascii_qid(uptr->player.U_Q_Id));
 */

end check_exit_status;
%page;
drop_restricted_object: procedure (me);
declare me bin(15);
declare what bin(15);
  
   what = ObjList(me)->object.param1->element(HANDS);
   if (what ^= 0) then
      if (ObjList(what)->object.gen_flags(RESTRICTED) = true)
          then call drop_object (ObjList(me), HANDS);

   what = ObjList(me)->object.param1->element(HEAD);
   if (what ^= 0) then
      if (ObjList(what)->object.gen_flags(RESTRICTED) = true)
          then call drop_object (ObjList(me), HEAD);

end drop_restricted_object;
%page;
check_for_empty_region: procedure;
declare region_empty     bit(1);
declare uno              bin(15);
declare (ptr,le)         pointer;

   region_empty = true;
   do uno = 1 to USERS_PER_REGION;
      if (UserList(uno) ^= null())
         then if (UserList(uno)->online  |  UserList(uno)->incoming) 
             then return;
      end;

   le = GhostList;
   do while (le ^= null());
      ptr = le->le_content;
      le  = le->le_next;
      if (ptr->player.online | ptr->player.incoming) then return;
      end;

   call flush_region;

end check_for_empty_region;
%page;
backout_incoming_avatar: procedure (p);
declare p pointer;
declare (the_class,the_style,cont_class,cont_pos) binary(15);
declare i binary(15);

   current_region.object_count = current_region.object_count -
                                 p->mug_shot.obj_cnt;

   RoomDBank.avatars_coming = RoomDBank.avatars_coming - 1;

   do i = 1 to 9;
      if (p->mug_shot.obj_class(i) ^= 0) then do;
         call extract_nibbles (p->mug_shot.obj_class(i),the_class,the_style);
         call extract_nibbles (p->mug_shot.obj_pos(i),cont_class,cont_pos);
         if (container_is_opaque (cont_class,cont_pos))
            then call note_instance_deletion (the_class,the_style);
            else call note_object_deletion (the_class,the_style);
         end;
      end;

end backout_incoming_avatar;
%page;
Build_Fan_List: procedure (user_qid,to_user);

declare user_qid         binary (31);
declare to_user          bit(1);           /* send to user_qid user? */

declare i                binary (15);
declare le               pointer;
declare ptr              pointer;

     fan_cnt = 0;
     do i = 1 to USERS_PER_REGION;
        if (UserList(i) ^= null()) then do;
           if ((to_user | UserList(i)->player.U_Q_Id ^= user_qid) & 
              UserList(i)->player.online) then do;
              fan_cnt = fan_cnt + 1;
              fan_list(fan_cnt) = UserList(i) -> player.U_Q;
              end; 
           end;
     end;

     le = GhostList;
     do while (le ^= null());
        ptr = le->le_content;
        le  = le->le_next;
        if ((to_user | ptr->player.U_Q_Id ^= user_qid) & 
           ptr->player.online) then do;
           fan_cnt = fan_cnt + 1;
           fan_list(fan_cnt) = ptr -> player.U_Q;
           end; 
        end;

end Build_Fan_List;
%page;
user_on_waiting_list: procedure (qid,uptr)  returns(bit(1) aligned);
declare qid              binary (31);
declare uptr             pointer;
declare le               pointer;

    le = RoomDBank.waiting_list;
    do while (le ^= null());
       uptr = le->le_content;
       le   = le->le_next;
       if (uptr->mug_shot.que = qid) then return(true);
       end;

    uptr = null();
    return (false);

end user_on_waiting_list;
%page;
GetUserPtr: procedure (qid,uptr);
declare qid              binary (31);
declare uptr             pointer;
declare le               pointer;
declare j                binary (15);

    do j = 1 to USERS_PER_REGION;
        if (UserList(j) ^= null())
        then if (UserList(j)->U_Q_Id = qid   &
                (UserList(j)->online | UserList(j)->incoming))
        then do;
             uptr = UserList(j);
             return;
        end;
    end;

    le = GhostList;
    do while (le ^= null());
       uptr = le->le_content;
       le   = le->le_next;
       if (uptr->player.U_Q_Id = qid  &
          (uptr->player.online | uptr->player.incoming))
          then return;
       end;

    uptr = null();

end GetUserPtr; 


FindUser: procedure (qid,uptr);
declare qid              binary (31);
declare uptr             pointer;
declare le               pointer;
declare j                binary (15);

    do j = 1 to USERS_PER_REGION;
        if (UserList(j) ^= null())
        then if (UserList(j)->U_Q_Id = qid) then do;
           uptr = UserList(j);
           return;
        end;
    end;

    le = GhostList;
    do while (le ^= null());
       uptr = le->le_content;
       le   = le->le_next;
       if (uptr->player.U_Q_Id = qid)
          then return;
       end;

    uptr = null();

end FindUser; 

find_user_by_name: procedure (username,uptr);
declare username         char(*) var;
declare this_name        char(10) var;
declare uptr             pointer;
declare le               pointer;
declare j                binary (15);

    do j = 1 to USERS_PER_REGION;
        if (UserList(j) ^= null()) then do;
           call compress_name (UserList(j)->U_Name, this_name);
           if (this_name = username) then do;
               uptr = UserList(j);
               return;
               end;
           end;
        end;

    le = GhostList;
    do while (le ^= null());
       uptr = le->le_content;
       le   = le->le_next;
       call compress_name (uptr->player.U_Name, this_name);
       if (this_name = username)
          then return;
       end;

    uptr = null();

end find_user_by_name; 

/*

GetUserIndex: procedure (qid,uno);
declare qid              binary (31);
declare uno              binary (15);
declare le               pointer;
declare j                binary (15);

    do j = 1 to USERS_PER_REGION;
        if (UserList(j) ^= null())
        then if (UserList(j)->U_Q_Id = qid   &
                (UserList(j)->online | UserList(j)->incoming))
        then do;
             uno = j;
             return;
        end;
    end;

    uno = 0;

end GetUserIndex; 
*/


GetUserEntry: procedure (qid,i);
declare qid              binary (31);
declare i                binary (15);
declare j                binary (15);

    do j = 1 to USERS_PER_REGION;
        if (UserList(j) ^= null())
        then if (UserList(j)->U_Q_Id = qid)
        then do;
             i = j; 
             return;
        end;
    end;

    i = 0;

end GetUserEntry; 



GetPtr_by_uid: procedure (uid,uptr);
declare uid              binary (31);
declare uptr             pointer;
declare j                binary (15);
declare le               pointer;

    do j = 1 to USERS_PER_REGION;
        if (UserList(j) ^= null())
        then if ( UserList(j) -> U_Id = uid) 
        then do;
             uptr = UserList(j);
             return;
        end;
    end;

    le = GhostList;
    do while (le ^= null());
       uptr = le->le_content;
       le   = le->le_next;
       if (uptr->player.U_Id = uid) then return;
       end;

    uptr = null();

end GetPtr_by_uid;
%page;
check_request_info: procedure (uid,req_type,uptr);
declare uid              bin(31);
declare req_type         bin(15);
declare uptr             pointer;

declare 1 user_env       like snap_env;
declare user_buffer      char(26) defined (user_env);
declare parm             bin(15);
declare parm_str         char(2) defined (parm);
declare curr_time        bin(31);
declare delta_time       bin(31);

     user_buffer = get_context_holding_area (CH$club_caribe);

     call s$int_date_time (curr_time);
     delta_time = curr_time - user_env.timestamp;
     if (delta_time > 45) then
        call info_trace_msg ('DELAY: user=' || ltrim(user_env.uid) ||
                        ', type= '     || ltrim(req_type) ||
                        ', region= '   || ltrim(user_env.region_id) ||
                        ', delta= '    || ltrim(delta_time));

     current_header  = user_env.header;
     current_noid    = user_env.objectid;
     current_request = user_env.function;

     parm = user_env.parm1;
     request_string = parm_str;
     parm = user_env.parm2;
     request_string = request_string || parm_str;

     if (user_env.region_id ^= Region) then do;
        call trace_msg ('Trans completed after region swap: ' || ltrim(uid) ||
                        '/' || ltrim(user_env.region_id) || ' type=' ||
                        ltrim(req_type));
        uptr = null();
        return;
        end;

     call GetUserPtr (user_env.qid,uptr);
     if (uptr = null()) then do;
        uptr = null();
        call info_trace_msg ('User for trans not found: ' || ltrim(uid) ||
                  '/' || ltrim(user_env.qid) ||  '/' || ltrim(Region));
        return;
        end;

     avatarptr = ObjList(uptr->player.object_slot);
     if (avatarptr = null()) then do;
        uptr = null();
        call info_trace_msg ('ObjList for trans user has been cleared: ' ||
                        ltrim(uid) || '/' || ltrim(Region));
        return;
        end;

     current_qid = uptr->player.U_Q_Id;

     if (uptr->player.online = false) then do;
        if (BUGON) then 
          call trace_msg ('Disconnect in mid transaction: ' || ltrim(uid) ||
                        '/' || ltrim(Region));
        uptr = null();
        return;
        end;

     selfptr = ObjList(current_noid);
     if (selfptr = null()) then do;
        uptr = null();
        call info_trace_msg ('ObjList for trans object has been cleared: ' ||
                        ltrim(uid) || '/' || ltrim(Region));
        return;
        end;
     userptr = uptr;

end check_request_info;
%page;
checkpoint_object: procedure(to_region,noid);
declare to_region bin(31);
declare noid      bin(15);

declare 1 request,
          2 region_id    bin(31),
          2 count        bin(15),
          2 list_data(1019) char(1);
declare obj_list char(1025) defined(request);
declare op     pointer;
declare base   bin(15);
declare save_noid bin(15);
declare all_objs bit(1) aligned;

   if (to_region = 0)
      then request.region_id = RoomDBank.Region;
      else request.region_id = to_region;
   request.count = 0;
   base = 1;
   op = addr(request.list_data(base));

   if (noid > 0) then do;
      if (ObjList(noid)->object.class = CLASS_AVATAR) then do;
         all_objs = true;
         call ckpt_description;
         save_noid = noid;
         noid = ObjList(save_noid)->object.param1->element(HANDS);
         if (noid ^= 0) then call ckpt_description;
         noid = ObjList(save_noid)->object.param1->element(HEAD);
         if (noid ^= 0) then call ckpt_description;
         noid = save_noid;
         end;
      else do;
         all_objs = false;
         call ckpt_description;
         end;
      if (request.count > 0) 
          then call send_msg_var (habitat_dbQ, MSG$CKPOINT_OBJECTS,
                         substr (obj_list,1,base+5));
      return;
      end;
   if (noid = 0) then do;
      call trace_msg ('*ERR* Attempt to checkpoint region object ' ||
                      ltrim(Region));
      return;
      end;

   all_objs = true;
   do noid = 1 to (OBJECTS_PER_REGION-1);
      if (ObjList(noid) ^= null()) then call ckpt_description;
      end;
   if (request.count > 0)
      then call send_msg_var (habitat_dbQ, MSG$CKPOINT_OBJECTS,
                              substr (obj_list,1,base+5));
                      
ckpt_description: procedure;
declare vary_st_len bin(15);

   if (all_objs) then
      if (^ object_has_changed(ObjList(noid))) then do;
         no_mod = no_mod + 1;
         return;
         end;

   yes_mod = yes_mod + 1;
   vary_st_len = Class_Table(ObjList(noid)->object.class).class_bytes;
   if (base + 5 + obj_fixed + vary_st_len  > big_msg_size) then do;
      call send_msg_var (habitat_dbQ, MSG$CKPOINT_OBJECTS,
                         substr (obj_list,1,base+5));
      request.count = 0;
      base = 1;
      op = addr(request.list_data(base));
      end;
   ObjList(noid)->object.gen_flags(MODIFIED) = false;
   call create_descriptor (op,noid,0,vary_st_len);
   if (to_region ^= 0  &  to_region ^= NULL_REGION) then do;
      op->obj_desc.container = 0;
      op->obj_desc.contype   = byte(0);
      end;
   base = base + vary_st_len + obj_fixed;
   op = addr (request.list_data(base));
   request.count = request.count + 1;
 
end ckpt_description;
end checkpoint_object;
%page;
checkpoint_current_region: procedure(uid);
declare uid    bin(31);

declare 1 request,
          2 region_id    bin(31),
          2 user_cnt     bin(15),
          2 user_id      bin(31);
declare obj_list char(10) defined(request);

   request.region_id = Region;
   request.user_cnt  = 1;
   request.user_id   = uid;

   call set_context_holding_area (CH$club_caribe, ' ');
   call send_msg_var (habitat_dbQ, MSG$CKPOINT_MY_REGION, substr(obj_list,1));

end checkpoint_current_region;
%page;
object_has_changed: procedure (op) returns(bit(1) aligned);
declare op          pointer;
declare its_class   bin(15);

  its_class = op->object.class;
  if (its_class = CLASS_TEST)      then return (true);
  if (its_class = CLASS_ATM)       then return (false);

  return (op->object.gen_flags(MODIFIED));

end object_has_changed;
%page;
checkpoint_text: procedure (text_key,text_data);
declare text_key    bin(31);
declare text_data   char(*) var;

declare 1 request,
          2 function     bin(15),
          2 id           bin(31),
          2 page         bin(15),
          2 data         char(640) var;
declare request_str char(648) defined(request);

  request.function = CC$dbf_write_text;
  request.id       = text_key;
  request.page     = 1;                         /* May need it later... */
  request.data     = text_data;
  
  call send_message (habitat_dbQ, MSG$DB_LOOKUP, request_str,
                     length(text_data) + 10, 0, RoomBQid);

end checkpoint_text;
%page;
send_mail_message: procedure (from,text_key) returns(binary(15));
declare from        pointer;       /* to the ObjList entry for sender */
declare text_key    bin(31);

declare 1 request,
          2 function     bin(15),
          2 sender_name  char(10),
          2 sender_uid   bin(31),
          2 text_id      bin(31);
declare request_str char(20) defined(request);

%replace rejected   by 0;
%replace accepted   by 1;

  if (text_key <= 0) then return (rejected);       /* No text in database */

  request.function    = CC$dbf_send_mail;
  request.sender_name = UserList(from->object.avatarslot)->player.U_Name;
  request.sender_uid  = UserList(from->object.avatarslot)->player.U_Id;
  request.text_id     = text_key;
  
  call send_message (habitat_dbQ, MSG$DB_LOOKUP, request_str, 20, 0,
                         RoomBQid);
  return (accepted);

end send_mail_message;
%page;
get_mail_message: procedure (who);
declare who    pointer;

declare 1 buff,
          2 function     bin(15),
          2 user_id      bin(31);
declare buff_str char(6) defined(buff);
declare 1 user_env       like snap_env;
declare user_buffer      char(27) defined (user_env);
        
  buff.function = CC$dbf_mail_check;
  buff.user_id  = who->object.obj_id;

  call s$int_date_time (user_env.timestamp);
  user_env.uid       = who->object.obj_id;
  user_env.qid       = userptr->player.U_Q_Id;
  user_env.region_id = Region;
  user_env.header    = current_header;
  user_env.objectid  = current_noid;
  user_env.function  = current_request;
  user_env.parm1     = 0;
  user_env.parm2     = 0;
  call set_context_holding_area (CH$club_caribe, user_buffer);

  call send_message (habitat_dbQ, MSG$DB_LOOKUP, buff_str, 6,
                     who -> object.obj_id, RoomBQid);

end get_mail_message;
%page;
handle_mail_check: procedure(buff);
declare buff             pointer;
declare 1 buff_olay      based (buff),
          2 function     bin(15),
          2 reader_uid   bin(31),
          2 text_id      bin(31),
          2 more         bin(15),
          2 curr_time    bin(31);

   call check_request_info (reader_uid,req$read_mail,userptr);
   if (userptr = null()) then return;               /* Requester has departed */

   if (buff_olay.more = 1)
      then userptr->player.has_mail = true;
      else userptr->player.has_mail = false;
   userptr->player.last_mail_ts = buff_olay.curr_time;
   call generic_READMAIL_result (buff_olay.text_id,buff_olay.more);

end handle_mail_check;
%page;
process_messager_name: procedure;
declare sender pointer;
declare tp     pointer;
declare msg    char(40) var;

  sender = UserList(avatar.avatarslot);

  call set_environment (sender, 0, 0);

  if (privileged_user()  &  substr(request_string,1,1) = '/') then do;
     /* See if you can figure out how to do an OLM to Q-Link here.  */
     /* For now, just do the normal ESP stuff.                      */
     end;

  call compress_name (request_string, msg);
  call send_message (habitatQ, MSG$FIND_NAME, substr(msg,1),
             length(msg),sender->player.U_Id,sender->player.U_Q_Id);

end process_messager_name;
%page;
process_messager_name_result: procedure(buff,uid);
declare buff pointer;
declare uid  bin(31);

declare 1 buf based(buff),
          2 list_name         character(10),
          2 list_uid          binary(31),
          2 list_qid          binary(31),
          2 list_version      binary(15);

   call check_request_info (uid,req$initiate_olm,userptr);
   if (userptr = null()) then return;            /* Requester has departed */

   if (buf.list_qid = 0) then do;
      call speak_msg (avatarptr, SPEAK$,
           'Cannot contact ' || rtrim(list_name) || '.', FAILURE); 
      end;
   else do;
      call r_msg_1 (NORM, SUCCESS);
      if (userptr->player.esp.to_qid ^= buf.list_qid) then do;
         userptr->player.esp.to_uid = buf.list_uid;
         userptr->player.esp.to_qid = buf.list_qid;
         userptr->player.esp.que    = null();
         end;
      end;

   userptr->player.esp.lines  = 0;

end process_messager_name_result;
%page;
process_messager_msg: procedure;


  if (userptr->player.esp.que = null()) then do;
     if (userptr->player.esp.to_qid = 0) then do;
        call trace_msg ('Bad ESP from ' || userptr->player.U_Name ||
                        ' to ' || userptr->player.to_uid || '/' ||
                         show_ptr(userptr->player.que));
        call trace_msg ('Previous cmd: ' || userptr->player.last_cmd);
        return;
        end;
     call open_queue_from_number(userptr->player.esp.to_qid,
                                 userptr->player.esp.que);
     end;

  call start_packed_msg (userptr->player.esp.que, userptr->player.esp.to_uid,
                         userptr->player.esp.to_qid);

  prefix = 'U' || byte(ASYNC_MSG);
/*response = byte(who->object.noid) || byte(14) || 'ESP From:  ' ||   */
  response = byte(0) || byte(OBJECTSPEAK_$) || byte(0) || 'ESP From:  ' ||
             userptr->player.U_Name;
  call encode_string (response,encoded);
  call send_tih_msg_packed (userptr->player.esp.que, prefix || encoded);

  prefix = 'U' || byte(ASYNC_MSG);
  response = byte(0) || byte(OBJECTSPEAK_$) || byte(0) || request_string;
  call encode_string (response,encoded);
  call send_tih_msg_packed (userptr->player.esp.que, prefix || encoded);

  call force_packed_msg (userptr->player.esp.que);
  userptr->player.esp.lines = userptr->player.esp.lines + 1;

end process_messager_msg;
%page;
process_new_mail: procedure(buff,uid);
declare buff        pointer;
declare uid         bin(31);
declare uindex      bin(15);
declare my_noid     bin(15);
declare paper_noid  bin(15);

declare 1 buf based(buff),
          2 postmark     binary(31);

%replace FIDDLE_$   by 12;
%replace C64_GR_STATE_OFFSET by 10;

   call GetPtr_by_uid (uid,userptr);
   if (userptr = null()) then do;
      call mail_for_incoming_user (uid);
      return;
      end;

   my_noid = userptr->player.object_slot;

   if (buf.postmark < userptr->player.last_mail_ts)           /* avoid race */
      then return;                                            /* condition  */
   if (userptr->player.has_mail = true) then return;

   userptr->player.has_mail = true;
   if (userptr->player.object_slot = GHOST) then do;
      if (userptr->player.online) 
         then call send_mail_notice (userptr->player.object_slot);
         else userptr->player.send_mail = true;
      return;
      end;    

   uindex = ObjList(my_noid)->object.avatarslot;
   call set_mail_object_values (uindex);

   paper_noid = ObjList(my_noid)->object.param1->element(4);
   
   if (^ userptr->player.online) then do;
      userptr->player.send_mail = true;
      return;
      end;

   call send_tih_msg (userptr->player.U_Q,
                      'U' || byte(ASYNC_MSG) || byte(0) ||
                      byte(FIDDLE_$) || encode_byte(paper_noid) ||
                      encode_byte(C64_GR_STATE_OFFSET) || byte(1) || byte(2));

   call send_mail_notice (my_noid);

end process_new_mail;
%page;
mail_for_incoming_user: procedure (uid);
declare uid    bin(31);
declare p      pointer;
declare le     pointer;

    le = RoomDBank.waiting_list;
    do while (le ^= null());
       p  = le->le_content;
       le = le->le_next;
       if (p->mug_shot.type = 2  &  p->mug_shot.user = uid) then do;
          p->mug_shot.mail = 1;
          return;
          end;
       end;

end mail_for_incoming_user;
%page;
privileged_user: procedure  returns (bit(1) aligned);

  if (q_context.user_group.internal) then return (true);
  if (substr(q_context.screen_name,1,3) = 'CCG') |
     (substr(q_context.screen_name,1,3) = 'QCC') then return (true);

  return (false);

end privileged_user;
%page;
flush_region: procedure;

   call checkpoint_object (0,-1);         /* Do em all! */
/* RoomDBank.initialized = false;         leave it set till new room started */

   if (BUGON) then 
      call trace_msg ('Region ' || ltrim(Region) || ' no longer active.');

end flush_region;
%page;
message_to_god: procedure (whatptr, whoptr, message);
declare 1 what based(whatptr) 
%nolist; %include 'struct_gen_object'; %list;
declare whatptr pointer;
declare 1 who based(whoptr) 
%nolist; %include 'struct_avatar'; %list;
declare whoptr pointer;
declare message character(*) varying;
declare uno    bin(15);
declare 1 request,
          2 asker        bin(31),
          2 askee        bin(31),
          2 text         char(128) var;
declare request_str char(138) defined(request);

   request.asker = who.obj_id;
   request.askee = what.obj_id;
   request.text  = message;

   call send_message (habitat_dbQ, MSG$ORACLE,request_str,length(request.text)+10, 
                      0,0);

   if (oracle.person = 0) then return;

   if (ObjList(oracle.person) = null()) then goto reset_oracle;
   uno = ObjList(oracle.person)->object.avatarslot;
   if (UserList(uno) = null()) then goto reset_oracle;
   if (UserList(uno)->player.incoming) then return;
   if (^UserList(uno)->player.online) then goto reset_oracle;

   call p_msg_s (NORM, whoptr, ObjList(oracle.person), SPEAK$, message);
   return;

reset_oracle:
      oracle.person = 0;
      return;
                      
end message_to_god;
%page;
set_environment: procedure (up,p1,p2);
declare up      pointer;
declare (p1,p2) bin(15);

declare env_buf char(26);
declare 1 environment  defined(env_buf) like snap_env;

   call s$int_date_time (environment.timestamp);

   environment.uid       = up->player.U_Id;
   environment.qid       = up->player.U_Q_Id;
   environment.region_id = Region;
   environment.header    = current_header;
   environment.objectid  = current_noid;
   environment.function  = current_request;
   environment.parm1     = p1;
   environment.parm2     = p2;

   call set_context_holding_area (CH$club_caribe, env_buf);

end set_environment;
%page;
handle_internal_cmds: procedure (target, buffer);
declare target bin(15);
declare buffer char(*) var;
declare str    char(32) var;
declare uptr   pointer;

   if ( ^privileged_user() ) then return;    /* Let it fall thru the cracks. */

   str = ltrim(buffer);
   if (substr (str,1,4) = 'gag ') then do;
      call compress_name (substr(str,5), str);
      call find_user_by_name (str,uptr);
      if (uptr ^= null()) then do;
          uptr->player.gagged = true;
          str = str || ' has been gagged.';
          call send_tih_msg (userptr->player.U_Q, 'U' || byte(ASYNC_MSG) ||
                 byte(0) || byte(OBJECTSPEAK_$) || encode_byte(avatar.noid) ||
                 str);
          call info_trace_msg (str);
          end;
      end;     /* processing for GAG command */
   else if (substr(str,1,6) = 'ungag ') then do;
      call compress_name (substr(str,7), str);
      call find_user_by_name (str,uptr);
      if (uptr ^= null()) then do;
          uptr->player.gagged = false;
          str = str || ' has been ungagged.';
          call send_tih_msg (userptr->player.U_Q, 'U' || byte(ASYNC_MSG) ||
                 byte(0) || byte(OBJECTSPEAK_$) || encode_byte(avatar.noid) ||
                 str);
          call info_trace_msg (str);
          end;
      end;     /* processing for UNGAG command */

end handle_internal_cmds;

show_ptr:  procedure (ptr) returns(char(9));
declare ptr     pointer;
declare p_bin31 bin(31) defined(ptr);
declare result  char(8);

   result = hex (p_bin31,8);
   return (result || 'x');

end show_ptr;

%page;
illegal: procedure;

     call force_user_dump ('ILLEGAL behavior: ');

end illegal;
